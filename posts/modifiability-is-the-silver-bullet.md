世の中には良いコードを書くための様々な原則、パターン、アーキテクチャが存在しますが、常に適用できるわけではありません。
良いコードを書くためには、これらの指針を実際のプロジェクトに適用するべきか、状況に応じて判断し続ける必要があります。

この投稿では、それらの原則の根底にある**変更容易性**を指針とすることで、迷わずに良いコードを書きやすくなるのではないか、という現時点での僕の考えを書いていきます。

また、この投稿は[達人プログラマー](https://www.ohmsha.co.jp/book/9784274226298/)の2.8章「良い設計の本質」を自分なりに解釈して理解するためのものです。

## 良いコードのための無数の指針

良いコードを書くための指針は無数に存在します。
例えば、DRY、KISS、YAGNI、SOLID、オブジェクト指向設計、デザインパターン、クリーンアーキテクチャ、可読性、再利用性、一貫性などがあります。

しかし、これらの指針は無条件に従えば良いコードがかけるようになるものではありません。
最近、Googleの社内コード品質の向上に取り組んでいるCode Healthというグループが、[DRY原則を厳格に適用しすぎると変更しづらくなるといった記事](https://testing.googleblog.com/2024/05/dont-dry-your-code-prematurely.html)を出していたりします。
また、SOLID原則のSである単一責任原則は「一つのモジュールは一つの責務を持つべきである」と誤解されることがありますが、
この原則は対象が人であり、[システムを扱う人が別であるなら同じ概念と思われるものも別々にするべきという原則](https://zenn.dev/magicant/books/0d7a8fddfba011/viewer/59c54c#:~:text=%E3%83%AC%E3%82%B9%E3%83%88%E3%83%A9%E3%83%B3%E3%81%AB%E3%81%84%E3%82%8B%E4%BA%BA%E3%81%AE%E7%AB%8B%E5%A0%B4%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E3%80%81%E6%96%99%E7%90%86%E3%81%A8%E3%81%84%E3%81%86%E6%A6%82%E5%BF%B5%E3%81%AB%E6%B1%82%E3%82%81%E3%82%89%E3%82%8C%E3%82%8B%E6%83%85%E5%A0%B1%E3%82%84%E6%A9%9F%E8%83%BD%E3%81%8C%E5%85%A8%E3%81%8F%E9%81%95%E3%81%86%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%81%8C%E5%88%86%E3%81%8B%E3%82%8A%E3%81%BE%E3%81%99%E3%81%AD%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%82%92%E4%B8%80%E3%81%A4%E3%81%AE%E3%80%8C%E6%96%99%E7%90%86%E3%80%8D%E3%81%A8%E3%81%84%E3%81%86%E6%A7%8B%E6%88%90%E8%A6%81%E7%B4%A0%E3%81%AB%E3%81%94%E3%81%A1%E3%82%83%E3%81%BE%E3%81%9C%E3%81%AB%E3%81%99%E3%82%8B%E3%81%AE%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%8F%E3%81%A6%E3%80%81%E5%88%A5%E3%80%85%E3%81%AE%E3%82%82%E3%81%AE%E3%81%A8%E3%81%97%E3%81%A6%E8%A8%AD%E8%A8%88%E3%81%97%E3%81%AA%E3%81%95%E3%81%84%E3%81%A8%E3%81%84%E3%81%86%E3%81%AE%E3%81%8C%E5%8D%98%E4%B8%80%E8%B2%AC%E4%BB%BB%E3%81%AE%E5%8E%9F%E5%89%87%E3%81%AE%E7%9C%9F%E6%84%8F%E3%81%A7%E3%81%99%E3%80%82)です。

無数に存在する指針をすべて誤解なく解釈し、いつ従うべきなのかという基準を覚えるのは難しいです。
その結果、特定の指針に常に従うという教条主義的な態度に流れてしまうか、従うべき状況が分からずなんとなくで従ったり従わなかったりしてしまうように思います。  

ちなみに僕は後者で、設計には常にトレードオフが存在しているという有名な文言だけ覚えたものの、存在するトレードオフの分析から目を逸らして、なんとなくで使っています。
こういった態度でも経験を積むことで、なんとなくの精度が向上して良いコードがかけるようになる可能性があるとは思うのですが、可能な範囲で言語化して再現性を上げたいのです。

では、どうすれば教条主義にもならず、なんとなくで使わないで済むようになるのでしょうか。  
これらの原因が、大量の指針を覚えるのが難しいという負担の問題であるなら、それを一つに絞ることで負担を減らすことができると考えました。

## 良いコードとは

指針を一つだけ用意するために、良いコードとはどういうものかを考える必要があります。
良いコードを定義することができれば、原則を適用する基準にすることができそうです。

多くのソフトウェアの目的は現実世界の課題を解決することです。なので良いソフトウェアとは「効果的に課題を解決できるもの」と言えます。
例えば、高速に動作する、バグが少なく仕様通りに動いている、多くのリクエストを捌くことができる、などです。
このようなソフトウェアを実現するためのコードが良いコードだというのは多くの人が認識していることであり、迷う余地はないと思います。

しかし、課題を解決するソフトウェアを一度作って終わりというのは多くありません。課題を解決した結果別の課題が出てきたり、
バグが見つかった場合には、ソフトウェアを変更する必要が出てきます。変更のたびにコードの様々な箇所を壊してしまったり、
変更のための期間が長引いてしまうと、良いソフトウェアから遠ざかってしまいます。そのため、変更しやすいコードも良いコードということができます。

まとめると、良いコードとは、

- 効果的に課題を解決できるコード
- 変更しやすいコード

であると言えそうです。

## 良いコードのための一つの指針

良いコードの条件のうち「効果的に課題を解決できる」は、ソフトウェア開発のベースラインとして常に存在しており、
コードを書く際には意識していると思います。
なので、良いコードを書くときの指針とするべきなのは、変更しやすいコード、つまり変更容易性のあるコードです。
世の中の原則の多くは、変更容易性の向上を目的として存在しています。

> 我々が知る限り、この世の中のあらゆる設計原則は、ETC(Easier To Change)原則を特殊化したものとなっています。  
>
> [達人プログラマー 熟達に向けたあなたの旅](https://www.ohmsha.co.jp/book/9784274226298/)

なので、変更容易性を原則を適用するかどうかの基準にすることができます。

## 変更容易性を指針にすると

変更容易性を良いコードの指針とした場合、コードを書くときに変更という視点でコードを見ることができるようになってきます。
それは、「変更しやすいコードを書く」というだけではなく、

- いつ変更されそうか
- 変更される頻度
- 何が変更されるのか
- 変更するときのコスト

などもあります。
無数の原則を覚えなければいけなかった時と状況が似ていますが、変更という軸があることで考えやすくなっていると感じています。  

しかし、これらの視点は将来の変更について考えるときの手がかりが存在していないときには役に立ちません。
そのような状態では、とりあえず小さく作ることを意識すると良いのではないかと考えています。
関心が混ざり合っているロジックを単純に関数に切り出したり、クラスにまとめたりといった単純な分割です。
コードを書き始めた初期の頃には、そのプロジェクトに対する理解が無く、変更に対する手がかりが少ないです。
そういったときに何もしないのではなく、複雑なことをしていると思う箇所を単に分離しておくことで、
将来プロジェクトに対する理解が増え、変更に対する手がかりが揃ったときに、構造の変更を行いやすくなると考えています。

もちろんその意識だけで良いコードがかけるようになるわけではありません。
将来の変更を過度に意識しすぎたり、初期段階で細かく分割しすぎてしまい変更がしづらくなってしまうことはあります。
そのような状態でも、変更という視点があることで振り返りやすくなり、効率的に経験を積むことができるのではないかと感じています。

## 変更容易性を指針にして考えてみる

ここからは自分が体験したことでも、誰かの経験を詳細に聞いたものでもなく、こういう事がありそうだなぁという勝手な想像です。
将来自分が体験したとき、実際にはどうだったかを振り返るかもしれません。

原則に固執して問題になった例として聞いたことがあるのは、抽象的なレイヤーを作りすぎて、変更するのが難しくなっているというものです。
例えば戦術的DDDのテクニックやクリーンアーキテクチャを参考にしたコードでよく耳にします。これに対して僕が何となく思うのは、
そういった抽象層はある変更は容易にするが、それ以外の変更を難しくするのではないかということです。

抽象的なレイヤーの一つに、特定のライブラリやフレームワークに依存させないためのレイヤーがあると思います。
あるライブラリを抽象化するためのレイヤーで、別のライブラリを使おうと思ったときに入れ替えやすくすることを狙ったもので、
そのライブラリ特有の機能を使えなくなるという問題があります。
このレイヤーは様々なライブラリを抽象化するものであるため、固有の機能を実装してしまうと、他のライブラリに切り替えられなくなってしまいます。
そのため、裏にあるライブラリの責務が小さいか、開発側が要件をコントロールできるとき以外で使用すると問題になりやすいのだと思います。

このような問題は、変更の頻度やコストを見誤ってしまった場合に発生しやすいと考えています。
頻度が少なく、手で書き換えたほうが速い変更にばかり着目してしまい、日常的に発生する変更に目を向けることができていないような状態です。

良いコードの指針として変更容易性を使用する場合にも、ある変更をコードの構造だけで解決することに固執してはいけないと感じています。

## さいごに

無数に存在する原則やパターン、アーキテクチャに惑わされないために、変更容易性を指針とすることで良いコードを書きやすくなるという考えを書きました。  

これは良いソフトウェアを開発するためのスタートラインです。
上では、良いソフトウェアを「効果的に課題を解決できるもの」としましたが、そのためには変更容易性の意識と、ソフトウェアの対象領域であるドメインの理解が不可欠です。
どちらか一方だけに目を向けることなく、良いソフトウェアを開発することを目指していく必要があると感じています。
