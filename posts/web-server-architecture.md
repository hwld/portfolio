Webアプリを開発していても、Webサーバーについての詳細な知識が必要になることは少ないです。
依然としてWebアプリはWebサーバーの上で動いてはいますが、クラウドのマネージドサービスで動かすことも多くなった現代でそういった知識が必要になるケースは、経験の少ない僕には想像できません。アプリのボトルネックはもう少し高いレイヤーにあることが多く、パフォーマンス改善のためならそちらを学ぶほうが効率が良いと考えています。

ただ、Webアプリを開発しているとWebサーバーがどのように動いているのか気になると思います。僕は気になります。
具体的には、Webサーバーがどのように複数のリクエストを処理しているのかがわかりませんでした。

この投稿はWebサーバーの仕組みについて、ネットワークプログラミングの概要からアーキテクチャまでを調べ、自分の理解のためにまとめたものです。

## Webサーバーとは

Webサーバーとは、リクエストを受けて何らかのデータをレスポンスとして返すソフトウェアやハードウェアのことです。
データとしてはHTMLページ、画像、CSSスタイルシート、JavaScriptファイル、JSONなどがあり、要求に応じてこれらのデータを返します。

現代のWebサーバーは複数のクライアントからのリクエストを並行して処理する必要があります。
一つのリクエストが処理されるまで他のリクエストをブロックするというように、リクエストを一つずつ処理するだけならイメージはつきやすいと思います。
しかし実際には並行処理が行われるため複雑になります。

Webサーバーのアーキテクチャは並行処理の手法の数だけ存在し、詳細を理解するためにはシステムプログラミングの領域に踏み込む必要があります。
処理を委譲する実行環境でアーキテクチャを分けると、マルチプロセス・マルチスレッド・イベント駆動・ハイブリッド・グリーンスレッドなどがあります。
また、各実行環境でリクエストが処理される方法も異なります。

## ネットワークプログラミングの概要

Webサーバーの仕組みを知るために重要なシステムプログラミングの領域はネットワーク通信です。
Webサーバーはクライアントからネットワークを通してリクエストを受け付けたあと、クライアントからデータを受け取ったり、クライアントにデータを渡したりします。

### 基礎知識

ネットワークプログラミングの概要を知るうえで前提となる基礎的な知識について解説します。

#### システムコール

ここではシステムコールを利用するプログラミングをシステムプログラミングと呼びます。

システムコールは、アプリケーションがOSのカーネルの機能を呼び出すための方法です。
現代のCPUではセキュリティのためにユーザーモードとカーネルモードを区別しています。
カーネルモードは無制限の操作が可能ですが、ユーザーモードには制限があります。
OSは、カーネルモードで動作する処理をシステムコールとして提供し、アプリケーションはシステムコールを通じてカーネルモードでの操作を実行します。

代表的なシステムコールとしては、`open`、`read`、`write`、`close`などがあり、ファイルの操作を行います。
後述するネットワーク通信で使用されるソケットに関連するものとしては、`socket`、`bind`、`listen`、`accept`、`connect`などがあります。
他にネットワーク通信で重要になってくるものだと、`select`や`epoll`(`kqueue`)のようなI/Oイベントの通知のためのシステムコールがあります。

#### ソケット

ネットワーク通信では、ソケットと呼ばれるインターフェースが使用されます。

> [!info]
> ソケットにはUDPで通信するためのUDPソケットや、ネットワークに限らないプロセス間通信を行うためのUNIXドメインソケットなどがありますが、ここでは
> ソケットとだけ言う場合にはTCPソケットを指します。

ソケットは通信におけるエンドポイントを表現したデータモデルのことで、

- ローカルIPアドレス
- ローカルTCPポート
- リモートIPアドレス
- リモートTCPポート

が含まれます。
例えばクライアントとWebサーバーが通信しているとき、Webサーバー側のソケットには、Webサーバー自身の情報がローカルIPアドレス・TCPポートに含まれており、
通信先のクライアントの情報がリモートIPアドレス・TCPポートに含まれています。

ネットワーク通信ではソケットを使用してクライアントからデータを受け取ったり、クライアントにデータを渡すことができます。
具体的には、ソケットを読み取ることでデータを受け取り、ソケットに対して書き込むことでデータを渡すことができます。

#### ファイルディスクリプタ

ソケットは**ファイルディスクリプタ**と呼ばれる整数によって参照されます。

ファイルディスクリプタはUnixにおいてプロセス内のファイルを参照するときに使用される整数のことで、Unixでは様々なリソースがこれによって参照されます。
ファイルやソケットのほか、接続されているキーボードや仮想デバイスであるターミナルなどもあります。
ファイルディスクリプタはプロセス内で一意な整数であり、プロセス間では一意な整数にはなっていません。

このファイルディスクリプタはOS内部に存在するオープンファイル記述と呼ばれるデータで管理されています。
オープンファイル記述の中でプロセスIDとファイルディスクリプタによって、どの情報が参照されるのかが決まります。

Unixのこのような思想は「**Everything is a file**」と呼ばれ、統一したインターフェースであらゆるリソースを扱えるようになります。
例えばファイルの読み込み・書き込みとソケットの読み込み・書き込みを同じシステムコールで行うことができます。

Web開発でもよく見る標準入力、標準出力、標準エラー出力にもファイルディスクリプタが割り当てられており、それぞれ0、1、2になっています。
画面への出力は、標準出力のファイルディスクリプタである1に対してファイル書き込みのシステムコールを実行することで実現できます。

### リクエスト処理のフロー概要

ソケットを使用してWebサーバーとしてリクエストを処理するには、ソケットに関するいくつかのシステムコールを呼ぶ必要があります。
リクエストを処理する流れは以下のようになります。

1. ソケットの作成 (socket)
2. ソケットにアドレス割り当て (bind)
3. 接続の待機 (listen)
4. 接続の受け付け (accept)
5. リクエストを処理...
6. ソケットのクローズ (close)

Rubyのsocketライブラリを使って書くと、以下のようになります。

```ruby
require 'socket'

server = Socket.new(:INET, :STREAM) # ソケットの作成
addr = Socket.pack_sockaddr_in(4481, '0.0.0.0')
server.bind(addr) # アドレスの割り当て
server.listen(5) # 接続の待機

connection, _ = server.accept # 接続の受け付け
# リクエストを処理...
connection.close
```

`Socket.accept`はリクエストがあるまで後続の処理をブロックし、リクエストが到着するとクライアントと接続されているソケットを作成します。
`accept`はクライアントとWebサーバーでTCPハンドシェイクによってコネクションを確立した時点でブロックを解除します。

この`accept`で作成されたソケットを読み書きしてクライアントとデータをやり取りします。
`accept`によって作成されるソケットには、WebサーバーのIPアドレスとTCPポートがローカル情報として、
クライアントのIPアドレスとTCPポートがリモート情報として含まれているため、クライアントとの通信に使用できます。

また、Rubyのsocketライブラリでは上のようなコードと合わせてリクエスト処理のループを以下のようなコードで簡単に実装できます。

```ruby
require 'socket'

Socket.tcp_server_loop(4481) do | connection |
  # リクエストを処理...
  connection.close
end
```

### ソケットのI/Oモデル

ソケットのI/Oに関するモデルについて解説していきます。

#### ブロッキングI/O

ソケットを読み書きする方法として、**ブロッキングI/O**があります。

**ブロッキングI/O**とは、I/O操作の前に待ちが発生して後続の処理がブロックされるI/Oです。
例えばソケットがノンブロッキングモードではない場合の`read`や`write`が該当します。
ブロッキングI/Oの場合、`read`はデータの読み込み準備が完了するまで処理をブロックし、`write`は書き込み準備が完了するまで処理をブロックします。
`read`はEOFを受け取るか最小バイト数を受け取るまで処理をブロックすることもあります。

ブロッキングI/Oを使用したコードは以下のようになります。

```ruby
require 'socket'

Socket.tcp_server_loop(4481) do | connection |
  request = connection.read
  connection.write request

  connection.close
end
```

#### ノンブロッキングI/O

ソケットを読み書きするもう一つの方法は、**ノンブロッキングI/O**です。

**ノンブロッキングI/O**とは、I/O操作の前に待ちが発生しそうなら即座に関数から返ってくるI/Oです。
例えばソケットがノンブロッキングモードである場合の`read`や`write`が該当します。
ノンブロッキングI/Oの場合、I/O操作の準備ができていないと関数からすぐに返ってきます。

ノンブロッキングI/Oを使用したコードの例は以下のようになります。

```ruby
require 'socket'

Socket.tcp_server_loop(4481) do | connection |
  loop do
    begin
      puts connection.read_nonblock(4096)
    rescue Errno::EAGAIN
      retry
    rescue EOFError
      break
    end
  end

  connection.close
end
```

`read`が準備中の場合にはリトライしていますが、あまり意味がないように見えます。
準備中の場合には`Errno::EAGAIN`が発行されるので、準備が完了するまで`read`を呼び続けています。
`read`がブロックしなくなったとはいえ、結局はループが発生しており、ブロッキングI/Oと変わらないように見えす。

#### I/O多重化

ノンブロッキングI/Oの真価は、**I/O多重化**と一緒に使うことで発揮されます。
詳細は後述するWebサーバーアーキテクチャのイベント駆動で解説します。

I/O多重化とは、`select`システムコールで複数のファイルディスクリプタを1プロセス1スレッドで管理することを指します。
`select`はI/Oイベントの通知を監視するためのシステムコールですが、効率があまり良くないので現代では効率の良い`epoll`や`kqueue`が使用されます。
インターフェースは異なっていますが、似たようなことを実現するシステムコールなので、ここでは`select`で説明します。

`select`は複数のファイルディスクリプタを監視し、I/O操作の準備が完了しているファイルディスクリプタを返すシステムコールです。
例えばWebサーバーが複数のクライアントと接続している場合、それらのソケットを`select`に渡すと、
I/O操作の準備ができたソケットが返ってきます。
準備ができているソケットがなかったりタイムアウトになるまで`select`は後続の処理をブロックします。

> [!info]
> `select`はファイルディスクリプタを受け取るのですが、通常のディスクファイルは常に準備完了状態とみなされるため、`select`に渡しても意味がありません。
>
> `select`では通常のファイルを渡してもエラーは出ないと思いますが、`epoll`では通常のファイルを渡すと[エラーになる可能性があります。](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html#top_of_page:~:text=EPERM%20%20The%20target%20file%20fd%20does%20not%20support%20epoll.%20%20This%20error%20can%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20occur%20if%20fd%20refers%20to%2C%20for%20example%2C%20a%20regular%20file%20or%20a%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20directory.)

`select`を使用する`IO.select`を使ったI/O多重化のコードは以下のようになります。

```ruby
connections = [<TCPSocket>, <TCPSocket>, <TCPSocket>]

loop do
  ready = IO.select(connections)

  readable_connections = ready[0]
  readable_connections.each do | conn | 
    data = conn.readpartial(4096)
    process(data)
  end
end
```

ここでは3つのソケットを`IO.select`の第一引数に渡し、読み込み準備が完了したソケットのデータが`IO.select`が返す配列の最初の要素に入っています。
`readpartial`は使用可能なデータをすぐに返すRubyの関数ですが、読み込み準備ができていない場合にはブロックします。
`select`から返って来ている時点でI/Oの準備が完了しているとみなしているためこれを使用しています。

`IO.select`は第一引数に読み込みたいIOオブジェクトの配列、第二引数に書き込みたいIOオブジェクトの配列を渡すことができます。
内部で`select`システムコールが呼ばれ、読み込みたいファイルディスクリプタの配列、書き込みたいファイルディスクリプタの配列が渡されます。

このI/O多重化を先述のノンブロッキングI/Oと一緒に使うことができます。
上のコードは事前にソケットが用意されていますが、実際にはどこかのタイミングで`connections`にソケットを詰める必要があります。
ここでノンブロッキングI/Oを使えます。簡単に説明すると、ノンブロッキングI/Oで準備中だとわかったときに`connections`にソケットを詰めることができます。
詳細は後述するWebサーバーアーキテクチャのイベント駆動で解説します。

#### 非同期I/O

ソケットを読み書きする方法として、**非同期I/O**もあります。

非同期I/Oは、I/O操作を発行するとすぐに関数から返り、バックグラウンドでI/O操作が実行されます。
Linuxで現在普及しているのはio_uringというもので、Linux独自のシステムコールとして非同期I/Oを実現しています。

ここで言っている非同期I/Oは、あくまでシステムコールレベルでの非同期I/Oです。
プログラミング言語やライブラリは、こういったシステムコールを直接使用せずにアプリケーションレベルの非同期I/Oを実現できます。
アプリケーションレベルの非同期I/Oは、システムコールではなく言語やライブラリが提供する関数でこれを実現する方法といえます。

例えばNode.jsで使われている非同期I/Oのためのライブラリであるlibuvはシステムコールレベルの非同期I/Oを使用していません。
ネットワークI/Oは[非同期I/OではなくノンブロッキングI/O + I/O多重化](https://docs.libuv.org/en/v1.x/design.html#:~:text=all%20(network)%20I/O%20is%20performed%20on%20non%2Dblocking%20sockets%20which%20are%20polled%20using%20the%20best%20mechanism%20available%20on%20the%20given%20platform%3A%20epoll%20on%20Linux%2C%20kqueue%20on%20OSX%20and%20other%20BSDs%2C%20event%20ports%20on%20SunOS%20and%20IOCP%20on%20Windows.)を使用していますし、
I/O多重化が使えないファイルI/Oは[非同期I/Oではなくマルチスレッド + ブロッキングI/O](https://blog.libtorrent.org/2012/10/asynchronous-disk-io/#:~:text=Benefits%20of%20using%20a%20thread%20pool%20with%20blocking%20operations%20instead%20of%20asynchronous%C2%A0disk%20operations)を使っています。

## Webサーバーアーキテクチャ

ここでは、Webサーバーが複数のリクエストを処理している手法で分類されたWebサーバーアーキテクチャについて解説します。
これらのアーキテクチャは[一つのリクエストを処理する方法](#リクエスト処理のフロー概要)がベースになっています。

### マルチプロセス

マルチプロセスは、複数のプロセスでリクエストの並行処理を実現するアーキテクチャです。

リクエストを受け付けてからプロセスを生成する方法と、事前に生成したプロセスを使う方法が存在します。
ここでは前者を**オンデマンド型**(造語です)、後者を**prefork型**と呼びます。

**オンデマンド型**はリクエストを受け付けてからプロセスを生成するアーキテクチャです。
処理の流れは以下のようなものが考えられます。

1. サーバーのメインプロセスが接続を受け付ける (`accept`)
2. サーバーのメインプロセスが子プロセスを`fork`する
3. 子プロセスでリクエストを処理し、メインプロセスは1に戻る

メインプロセスは接続を受け付けるためのソケットを持っており、`accept`したあとに`fork`します。
`fork`では親プロセスのファイルディスクリプタを子プロセスにコピーするため、`accept`で作成されたソケットを子プロセスで操作できます。

オンデマンド型にはシンプルな実装で複数リクエストを並行処理できるというメリットはありますが、リクエスト毎の`fork`は無駄なので事前に生成するアーキテクチャもあります。
また、大量のリクエストでプロセスの数が膨大な量になってしまい、システムがダウンするという問題が発生する可能性があります。

**prefork型**は事前に子プロセスを生成しておき、子プロセスでリクエストを受け付けるアーキテクチャです。
処理の流れは以下のようなものが考えられます。

1. サーバーのメインプロセスが接続を待機するソケットを作成する
2. サーバーのメインプロセスが指定の数だけ子プロセスを`fork`する
3. 子プロセスが1で作成したソケットで接続を受け付け、処理する

メインプロセスで事前に待機用のソケットを作成して、複数の子プロセスがそのソケットを使って接続を受け付けます。
`fork`するとソケットが親子と兄弟間で共有され、接続があった場合にはどれか一つのプロセスだけが応答します。

prefork型にはリクエストのたびに`fork`のコストを払う必要がないというメリットはありますが、多くのメモリを消費してしまうというデメリットはあります。
また、上の例だと事前に生成したプロセス以上のリクエストがあると性能が落ちてしまいます。

prefork型が使われているWebサーバーソフトウェアとしては、
PHPでよく使われるApache HTTP Server (preforkモジュール)があります。

### マルチスレッド

マルチスレッドは、複数のスレッドでリクエストの並行処理を実現するアーキテクチャです。

リクエストを受け付けてからスレッドを生成する方法と、事前に生成したスレッドを使う方法が存在します。
ここでは前者を**オンデマンド型**(造語です)、後者を**スレッドプール型**と呼びます。

このアーキテクチャはマルチプロセスと似ていますが、プロセスとスレッドにはいくつか違いがあります。
プロセスはスレッドよりも分離性が高く、プロセス間ではメモリを共有しませんが、スレッド間ではメモリを共有します。
一方で、プロセスはメモリを共有せずコピーするので生成のコストが高く、スレッドは共有するので生成のコストが低いです。

**オンデマンド型**はリクエストを受け付けてからにスレッドを生成するアーキテクチャです。
処理の流れは以下のようなものが考えられます。

1. サーバーのメインスレッドが接続を受け付ける (`accept`)
2. サーバーのメインスレッドがスレッドを生成する
3. スレッドでリクエストを処理し、メインスレッドは1に戻る

スレッドはメモリを共有するので、`accept`で生成したソケットをスレッドの中で使用することができます。
プロセスと違いメモリをコピーするわけではないので、ソケットをグローバルな領域に保存しておくとリクエストが分離できないことに注意が必要です。

マルチスレッドのオンデマンド型は、マルチプロセスのオンデマンド型と同じメリット・デメリットがあります。
プロセスと違うのはスレッドのほうが分離性と生成のコストが低いことです。

**スレッドプール型**は事前にスレッドを生成しておき、スレッドでリクエストを受け付けるアーキテクチャです。
処理の流れは以下のようなものが考えられます。

1. サーバーのメインスレッドが接続を待機するソケットを作成する
2. サーバーのメインスレッドが指定の数だけスレッドを生成する
3. スレッドが1で作成したソケットで接続を受け付け、処理する

メインプロセスで事前に待機用のソケットを作成して、複数のスレッドがそのソケットを使って接続を受け付けます。
スレッドはメモリを共有しているので、ソケットを共有することができ、接続があった場合にはどれか一つのスレッドだけが応答します。

こちらもマルチプロセスのprefork型と同じメリット・デメリットがあります。
また、プロセスとスレッドの違いによるメリット・デメリットはオンデマンド型と同じです。

### イベント駆動 (Reactorパターン)

イベント駆動は、シングルスレッドで動作するイベントループで複数のリクエストを並行処理するアーキテクチャです。
一般的には[ノンブロッキングI/O](#ノンブロッキングio)と[I/O多重化](#io多重化)が使用されます。

イベント駆動の処理の流れは以下のようなものが考えられます。`select`を想定していますが、より効率的な`epoll`(`kqueue`)でも同じような流れになります。

1. サーバーは接続を待機するソケットを作成し監視する
1. 接続があったら、監視するソケットのリストにそのソケットを追加する
1. サーバーは1と2の接続を監視する
    - 1.a
1. アクティブな接続が読み取り可能という通知を受けると、一定サイズだけ読み取る
1. アクティブな接続が書き込み可能という通知を受けると、一定サイズだけ書き込む

### ハイブリッド

## Webサーバーの変遷

## リバースプロキシ/ロードバランサ

## さいごに

## 参考資料

- [2015年Webサーバアーキテクチャ序論](https://blog.yuuk.io/entry/2015-webserver-architecture)
- [Webサーバーアーキテクチャ進化論2023](https://blog.ojisan.io/server-architecture-2023)
- [WebエンジニアとWeb技術とシステムの話 (sadnessOjisanのWebサーバーアーキテクチャ進化論2023を読んだ感想)](https://blog.inductor.me/entry/2023/04/03/153149)
- [なるほどTCPソケット(Working with TCP sockets)](https://www.snoozer05.org/naruhotcp)
- [Webサーバにおけるソケット周りの知識](https://christina04.hatenablog.com/entry/socket-base)
- [Non-Blocking I/O, I/O Multiplexing, Asynchronous I/Oの区別](https://christina04.hatenablog.com/entry/2017/07/05/005944)
- [I/O Multiplexing（I/O多重化）](https://christina04.hatenablog.com/entry/io-multiplexing)
- [ノンブロッキングI/Oと非同期I/Oの違いを理解する](https://blog.takanabe.tokyo/2015/03/%E3%83%8E%E3%83%B3%E3%83%96%E3%83%AD%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0i/o%E3%81%A8%E9%9D%9E%E5%90%8C%E6%9C%9Fi/o%E3%81%AE%E9%81%95%E3%81%84%E3%82%92%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B/)
- [「同期I/O」と「非同期I/O」の定義、とか](https://hirose31.hatenablog.jp/entry/20070815/1187149760)
- [Linuxにおける非同期IOの実装について](https://qiita.com/tmsn/items/0b9e5f84f9fbc56c1c82)
- [epoll_ctl(2) — Linux manual page](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html)
- [libuv - Design overview](https://docs.libuv.org/en/v1.x/design.html)
- [process-book - ファイルディスクリプタ](https://shinpeim.github.io/process-book/004.md/)
