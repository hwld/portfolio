
データベースには、トランザクションとACID特性、ロック、アノマリーとトランザクション分離レベルなどの概念がありますが、
それらがどのように関連しているかについて考えたことがありませんでした。

この投稿は、RDBの同時実行制御という観点からそれらの概念を自分の理解のためにまとめたものです。
トランザクション分離レベルについて詳しく整理されている[スライド](https://speakerdeck.com/mpyw/postgres-niokerutoranzakusiyonfen-li-reberu)と[記事](https://zenn.dev/mpyw/articles/rdb-transaction-isolations#postgres)の内容をベースにしています。

## RDBの同時実行制御の概要

### 同時実行制御とトランザクション

RDBには、連続した操作の単位としてトランザクションがあり、ACID特性を満たしていると言われています。
ACID特性のなかでわかりやすいと思うのは原子性(Atomicity)で、一連の操作がすべて実行されるか、すべて実行されないかのどちらかであることを保証する性質です。
トランザクション内の一部の操作が失敗した時点で、それ以前の操作はデータベースによってロールバックされ、なかったことにしてくれます。

ACID特性で同時実行制御と深く結びついているものは分離性(Isolation)です。
分離性とは、トランザクションを実行する過程が外のトランザクションから独立して見えないという性質のことです。
最も理想的なのは、複数のトランザクションが同時に実行されても、直列に実行されたような結果になるというもので、Serializableであるといいます。

### 同時実行の問題とロック

トランザクションに分離性がない場合には、複数のトランザクションが同時に実行されると問題が発生する可能性があります。
ここでは以下のような問題について考えていきます。

1. 別のトランザクションの変更を上書きしてしまう問題
2. 別のトランザクションがコミットしていない変更を読み取ってしまう問題

1の問題は、口座残高が十分にあるかを確認してから一定金額を引き落とす処理を一つのトランザクションとしたとき、これを同時に実行すると起きます。
あるトランザクションが残高の確認をした直後で、一定金額を引き落とす前に、別のトランザクションが残高の確認をすると、意図しない残高を読み取り、最終的な残高がおかしくなってしまいます。

2の問題は、口座残高を減少させるトランザクションと、口座残高を読み取るトランザクションを同時に実行すると起きます。
残高を減少させる処理が実行されたあと、別のトランザクションが残高を読み取ります。その後、残高を減少させるトランザクションが失敗した場合、
残高を読み取っているトランザクションは、正しくない残高を持っていることになります。

これら問題を解決するために、対象の行をロックして別のトランザクションの読み取りを防ぐという方法が考えられます。
問題1では口座確認の時点で、問題2では残高を減少させる時点でロックを取り、更新が終わるまで読み取りを待機させることができます。

データベースのロックはデータの不整合を防ぐ重要な機能ですが、過度なロックの使用はパフォーマンスの低下を引き起こします。
ロックを使用することでトランザクションの分離性を高めることはできるのですが、パフォーマンスのためにできるだけロックを減らす必要があります。
実際には、問題2をロックを使用せずに解決しているデータベースが多くあります。

### トランザクション分離レベル

ANSI(米国国家規格協会)は、分離性が無いことで発生する異常である**アノマリー**に対して、それをどのくらい防ぐかという**トランザクション分離レベル**を定義しました。

一番強い分離レベルでは、あらゆる操作にロックを掛けたような挙動になっているデータベースもあるのですが、
パフォーマンスの観点から現実的ではなかったり、ある程度の不整合は問題にならないことが多いので、整合性を妥協するための選択肢が用意されています。
