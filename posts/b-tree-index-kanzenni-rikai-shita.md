
>リレーショナルなSQLデータベースかリレーショナルでないシステムかに関わらず、正しいインデックスを作ることは、クエリの応答時間を短くする最善の方法です。  
>[USE THE INDEX, LUKE!](https://use-the-index-luke.com/ja/sql/performance-scalability/response-time-throughput#:~:text=%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%81%AASQL%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%8B%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%81%A7%E3%81%AA%E3%81%84%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%8B%E3%81%AB%20%E9%96%A2%E3%82%8F%E3%82%89%E3%81%9A%E3%80%81%E6%AD%A3%E3%81%97%E3%81%84%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%82%92%E4%BD%9C%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AF%E3%80%81%E3%82%AF%E3%82%A8%E3%83%AA%E3%81%AE%E5%BF%9C%E7%AD%94%E6%99%82%E9%96%93%E3%82%92%E7%9F%AD%E3%81%8F%E3%81%99%E3%82%8B%E6%9C%80%E5%96%84%E3%81%AE%E6%96%B9%E6%B3%95%E3%81%A7%E3%81%99%E3%80%82)

僕はパフォーマンスチューニングをしたことがありません。RDBのインデックスを使うとクエリが速くなるという話は聞いたことがありましたが、
実際のSQLに対してどのようにインデックスが使用されて、どれくらいのパフォーマンスが出ているのかは考えたことがありませんでした。

そんなときに、RDBのインデックスとチューニングについて書かれている[USE THE INDEX, LUKE!](https://use-the-index-luke.com/ja/sql/preface)
というオンラインブックを見つけ、とても参考になりました。この投稿は、そのオンラインブックを自分の理解のためにまとめたものです。

> [!info]
> インデックスには様々な種類がありますが、ここではB-tree(B+tree)について書きます。

## 1.インデックスの構造とパフォーマンス

### インデックスの構造

インデックスはクエリの実行を速くするために存在し、双方向連結リストと探索木というデータ構造を組み合わせたものになっています。
双方向連結リストは連続したデータへの効率的なアクセスのために使用され、探索木は高速な検索のために使用されています。

インデックスは実際のテーブルデータとは別に、メタデータとして持たせます。
実際のテーブルデータを連続的なデータにすると、更新のたびに大量のデータをずらす必要が出てくるのでパフォーマンスが悪いです。
その対策としてテーブルデータの並び順とは独立して、論理的な順序付けを作っています。

> [!info]
> MySQLではクラスタ化インデックスというものが使用されており、これはインデックスの中にすべてのテーブルデータが入っています。

インデックスは、インデックスを張ったカラムであるキーと、テーブルデータ行への参照の組を複数持つリーフノードが双方向連結リストで繋がれています。
インデックスから行を取得するためには、キーを使用してリーフノードを見つけ、テーブルデータ行への参照を使って、実際のテーブルデータにアクセスします。

双方向リストだけでは、キーを探すのに連続的なアクセスが必要になるので、探索木を使用して効率的に検索できるようにしています。
探索木は、各リーフノードから一つ選んだキーを一定数並べてブランチノードとします。さらに各ブランチノードから一つ選んだキーを一定数並べてルートノードとします。
これらのノード同士を参照させて、ルートノードからキーの大小によって効率的に検索が行えるようにしています。

探索木は、リーフノード数の増加に対して木の深さの増加が遅いため、データが増加してもパフォーマンスが下がりにくいという性質があります。
探索木の検索は、親ノードから子ノードをたどっていく構造なので、たどる数は木の深さによって決まります。
そのため、木が浅いほうがパフォーマンスが良くなりやすいです。

### インデックスを使っても検索が遅い？

インデックスを使えば必ず検索が効率化するとは限らず、インデックスを利用していても期待するほど高速にはならない場合もあります。
インデックスが劣化してくるのが原因だとよく言われていましたが、インデックスの再構築によってリーフノードを減らしても、
殆どの場合インデックスの深さは削減されないため、パフォーマンスはそこまで良くなりません。

検索が遅い原因は2つで

- リーフノードのチェーン
- テーブルへのアクセス

です。

1つ目のリーフノードのチェーンは、双方向連結リストによって繋げられたリーフノードを大量に辿らなければいけないときに問題になります。
非ユニーク列にもインデックスを貼ることはできるので、特定の値が複数存在する場合や、範囲検索を行う場合には、複数のリーフノードをたどる必要があり、問題になるかもしれません。

2つ目のテーブルへのアクセスは、検索の度に大量のテーブルへのアクセスが発生しているときに問題になります。
一つのリーフノードだけでも数百のエントリを保持していることがあり、対応するテーブルの行は、通常、たくさんのテーブルブロックに分散して保存されています。
データベースは同じテーブルブロックに格納されているデータは1回の読み込みで取得できるのですが、複数のデータブロックに分散している場合、データベースは多くの行を読み取る必要が出てくるため、問題になりやすいです。

インデックスによる検索は、

1. ツリーの走査
2. リーフノードのチェーンをたどる
3. テーブルからデータを読み出す

という手順で行われます。ツリーの走査はインデックスの深さによって効率的に行うことができるのですが、
それ以外の2ステップではたくさんのブロックにアクセスする必要があるため、検索が遅い原因になってしまいます。

### アクセス・フィルター述語

インデックスを使用した検索が遅くなっている原因を知るために、クエリの実行計画からアクセス・フィルター述語を確認するのが役に立つ場合があります。

>[!info]
>使用しているRDBによっては述語が明示的に表示されていない場合があります。
[このページ](https://use-the-index-luke.com/ja/sql/explain-plan)には様々なRDBの述語の確認方法が載っています。

アクセス述語は、インデックス操作の始めと終わりを決める条件です。つまり、リーフノードの走査の開始と終了の条件を表しています。
例としてOracleの実行計画では、`INDEX UNIQUE SCAN`というアクセス方法で、`access("EMPLOYEE_ID"=123)`
というアクセス述語が使用されているといった情報が表示されます。
このアクセス述語は、インデックスツリーの中で`EMPLOYEE_ID`が123であるエントリだけを取得していることを表しています。

フィルター述語には、インデックス・テーブルの2種類が存在し、インデックスフィルター述語はリーフノード走査時に適用されるフィルターで、
テーブルフィルター述語はテーブルデータをロードしたあとに適用されるフィルターです。
Oracleの実行計画では、`filter("SUBSIDIARY_ID"=30)`のように表示されます。
テーブルフィルター述語はインデックスフィルター述語と違い、実際のテーブルを読み込む必要があるため、
アクセス対象となっているリーフノードの数が大きい場合には、無駄なテーブルアクセスが増えてしまうため、遅くなってしまいます。

インデックスを使って効果的に検索を行うためには、できるだけフィルター述語を減らしてアクセス述語だけで検索が行われている必要があります。
アクセス述語とインデックスフィルター述語が使用されている場合には大量のリーフノードを走査している可能性があり、
アクセス述語とテーブルフィルター述語が使用されている場合には大量のテーブルアクセスが発生している可能性があります。

### インデックスを使用したクラスタリング

インデックスはデータをクラスタリングすることができ、遅くなる原因である大量のテーブルアクセスを減らすことができます。
データのクラスタリングとは、少ないI/O処理でアクセスできるように、連続的にアクセスされるデータを近くに保存することをいいます。
インデックスは順序を持っており、近い値が隣同士になるように作られるため、データをクラスタリングすることができます。

パフォーマンス向上のためのクラスタリングとして、

- 意図的なフィルター述語の使用
- カバリングインデックス
- クラスタ化インデックス

があります。

意図的なフィルター述語の利用では、テーブルフィルターをインデックスフィルターとして使用することで、テーブルアクセスを減らすことができます。
WHERE句の条件にインデックスを使用できない場合、その条件はテーブルフィルターとして使われることになるのですが、
テーブルフィルターではテーブルデータをロードする必要があるため、条件と一致しない行が多いほど無駄になってしまいます。
そこで、インデックスに列を追加してインデックスフィルターとして利用させることでフィルタリングをインデックスだけで行えるようにできます。

カバリングインデックスは、クエリに必要な情報がすべてインデックスに存在している状況のことで、テーブルアクセスを完全になくすことができます。
クエリのSELECTやWHEREに存在する列がすべてインデックスに乗っている場合に

クラスタ化インデックスは、すべてのテーブルデータが保存されているインデックスです。
1つのインデックスしか持たないテーブルの場合には向いているのですが、インデックスが複数あるとパフォーマンスが落ちてしまいます。
2つ目以降はセカンダリインデックスと呼ばれ、データにはクラスタ化インデックスのキーが格納されており、テーブルにアクセスするためにはクラスタ化インデックスを走査する必要が出てくるためです。

インデックスは参照を効率的に行えますが、更新系のクエリにとってはネガティブな影響を与えることが多いため、インデックスの数は小さく保つことが非常に重要です。
データがインサートされるとインデックスにもデータを追加する必要がありますし、
インデックスツリーのバランスを保つためのメンテナンスも行う必要があるため、インデックスが増えるほどこのコストが大きくなってきます。

## 2.インデックスはどう使われるか

### WHERE

### JOIN

### ORDER BY, GROUP BY

### LIMIT

## さいごに
