僕が開発していた小さいWebアプリで問題が発生したとき、クラウドが提供してくれる基本的なメトリクスやログから原因を特定して解決しました。
そのWebアプリは少ないコンポーネントで構成されていたため、あまり大変ではありませんでした。
しかし、複数のコンポーネントが複雑に絡み合っているようなWebアプリで、単純なメトリクスやログから原因を特定するのは大変そうだと感じました。
そういったWebアプリの問題の原因を特定するには、深い知識や経験が求められるため、簡単に行えるものではないと思います。

世の中のサービスはどうしているんだろうと調べていると、どうやら**オブザーバビリティ**というものが関わっていそうでした。
シンプルなモニタリングでは原因の調査に深い知識が必要ですが、オブザーバビリティは原因の調査をサポートしているらしいです。

この投稿は、オブザーバビリティの概要を自分の理解のためにまとめたものです。

## オブザーバビリティとは

**オブザバービリティ**とは、**システムで何が起こっているかを把握する能力**のことです。
オブザーバビリティは能力のことなので、低い状態から高い状態が存在します。
クラウドサービスでは基本的なメトリクスは表示できることが多いので、オブザーバビリティが0ということは滅多にないと思います。
また、オブザーバビリティが100という状況も今の時点では現実的ではありません。
あらゆる情報を出力するようになると、情報を保存するコストやパフォーマンスに対するオーバーヘッドが増えてしまうからです。

オブザーバビリティのためのサービスを提供するベンダーでは、
オブザーバビリティをどの程度持っているかという**オブザーバビリティ習熟度モデル**が作られていることが多いです。
例えばレベル1~3のように分けられており、各レベルごとにどの程度システムで何が起こっているかを把握できるのかが定められています。
このモデルを使用して、サービスにどの程度オブザーバビリティを持たせるのか、そのために何をするべきかを決めることができます。

オブザーバビリティはシステムの内部状況の把握能力なため、システムのライフサイクルの全てのフェーズに関わってきます。
例えばオブザーバビリティは、障害対応、パフォーマンスのボトルネックの特定、ユーザー行動の傾向分析によるシステムの改善点の発見などにも関わってきます。

## モニタリングとオブザーバビリティ

オブザーバビリティと似た文脈で**モニタリング** (監視)という言葉が使われることもあります。
モニタリングとはシステムの振る舞いや出力を観察しチェックし続ける行為のことです。
オブザーバビリティは能力のことなので直接比較できるものでは無いと思うのですが、
オブザーバビリティとモニタリングの目的が比較されることはよくあります。

モニタリングとオブザーバビリティは目的が異なっており、モニタリングは障害を検出すること、オブザーバビリティは障害を調査することを目的としています。
モニタリングは障害が発生した際に様々な出力によって障害を検出することはできますが、その後の原因の発見までをカバーしていません。
一方でオブザーバビリティは原因の発見までをカバーしています。
モニタリングでは出力された情報をもとに推測を行って原因を見つける必要がありますが、
一定のオブザーバビリティを持っている場合には出力された情報のみで原因を発見できるようになります。

また、モニタリングはシステムの状態を事前に定義された閾値と比較して異常を検出するために予測できない障害の対応が難しいのですが、
一定のオブザーバビリティを持っていると比較的容易になります。
事前に定義された閾値と比較するため、閾値が設定されていない問題を見落とす可能性があります。
オブザーバビリティでは詳細なデータを収集することができるため、これに対応できる可能性が高いです。

## オブザーバビリティの利点

上述したように、オブザーバビリティはモニタリングにある以下の問題を改善できます。

- 問題の原因を特定するのが難しい
- 予測できない障害の対応が難しい

オブザーバビリティはこれらの障害対応における問題を**高カーディナリティと高ディメンションなデータ**の収集や、それによる**データの統合**によって改善することができます。
カーディナリティはデータセット内の一意の値の数を表し、ディメンション(次元)はデータ内の属性を表します。

**高カーディナリティ**とは、データセット内で一意な値の数が多い状態を指します。
ユーザーIDやIPアドレスなどは比較的高いカーディナリティを持っているといえます。
高カーディナリティは一般的には詳細度が高いとも言えます。
例えばユーザーの年齢を考えたとき、10代や20代という値を持つ属性はカーディナリティが低く、10歳や11歳という値を持つ属性はカーディナリティが高く、詳細なデータと言えます。
このように、カーディナリティが高いとデータを詳細に分析することが可能なため、問題の原因を突き止めやすくなります。

> [!info]
> 高カーディナリティを求めすぎると、データが莫大な量になる危険性があります。
> 上記で年齢の例えを出しましたが、ここを時間にして考えると、いくらでも細かい単位で区切ることができ、データの数が増加するのは想像しやすいと思います。
>
> データの保存にはそれだけコストがかかるので、どの程度のカーディナリティが必要なのかは状況に合わせて考える必要があります。

**高ディメンション**とは、データに含まれる属性の数が多い状態を指します。
ディメンションとはデータの属性のことをいいます。
高ディメンションは一つのデータに様々な観点の情報が含まれていると考えることができるので、データを多角的に分析することが可能になり、問題の原因を突き止めやすくなります。

また、高カーディナリティによって様々な**データの統合**が可能になり、障害対応が更に容易になります。
例えばあるデータにIDが含まれている場合、他のデータがそのIDを参照できるようになり、データの統合を行うことができます。
これによって複数のデータを関連付け、さらに多角的な分析が可能になります。

このように、高カーディナリティで高ディメンションなデータを収集して探索することで、モニタリングの障害対応における問題は改善することができます。
詳細で多角的なデータによって問題の原因を突き止めやすくなったり、予測できなかった問題を発見することができます。

これらのデータの収集と探索は、システムが何が起こっているかを把握する能力を向上させることができるので、障害対応以外にも利用することができます。
例えばパフォーマンスのボトルネックを特定したり、ユーザー行動の傾向を分析することでシステムの改善点を発見するのにも利用することができます。

## シグナル

オブザーバビリティのためにシステムが出力するデータは**シグナル**と呼ばれ、いくつかの種類に分類されています。
ここまででデータと呼んでいたものはシグナルのことを指しています。

現時点ではシグナルには主要な3つのシグナルと、その他の2つのシグナルが存在します。
主要な3つのシグナルはオブザーバビリティの3本柱と呼ばれることもありますが、
3つすべてが必須なわけではなかったり、実際にはシグナル同士の関連も重要なため、別の呼び方も出てきています。

主要なシグナルとしてはメトリクス・ログ・トレースがあり、その他のシグナルとしてはプロファイラ・ダンプなどがあります。

### メトリクス

**メトリクス**とは、実行時に取得されるサービスの測定値のことで、基本的には時系列データです。
例えばCPU使用率、メモリ使用率、ディスクI/O、ネットワークトラフィックなどが該当します。
インフラ以外では、リクエスト数、エラーの数、リクエストのレイテンシなどもあります。

メトリクスは名前、ラベルのセット、数値で構成されます。
ラベルはメトリクス分析の切り口となるもので、ラベルのキーと値のセットになっており、分析したい切り口によって最適なラベルを決める必要があります。
数値は実際の測定値を表しています。

メトリクスには一般的にサポートされる以下の3つのタイプが存在します。

- **ゲージ**
    - 現在の値を示すメトリクス
    - 例としては、各種使用率やトラフィック
- **カウンター**
    - 増加する値を示すメトリクス
    - 例としては、リクエストの数やエラーの数
- **ヒストグラム**
    - 値の分布を示すメトリクス
    - 例としては、リクエストのレイテンシ

メトリクスは正しく使用することで、予測可能な障害に対する最も効率の良いシグナルになります。
基本的には時系列データなのでトラフィック量の増加に対してシグナルの量が変わらなく、コストの効率が良いです。
また、メトリクスは測定値という注目すべき値が明確なため、状況を簡単に把握しやすいという利点があります。

一方で、メトリクスに高カーディナリティのラベルを含めるとデータの肥大化が発生する可能性があるため、コストとそのラベルによる分析の価値のバランスを取る必要があります。

メトリクスの用途としてはアラートや分析があります。
メトリクスは測定値を持っているため、事前に設定したしきい値を超えた場合にアラートを出して障害を知らせることができます。
また、システムのパフォーマンスや動作の傾向を把握することもできます。

メトリクスは何が起こっているかを把握することはできますが、必ずしもその原因を明らかにするわけではありません。

### ログ

**ログ**とは、サービスで発生したイベントを記録するものです。
ログは、アプリケーションログ、セキュリティログ、システムログ、監査ログ、インフラログなどのカテゴリに分類できます。

ログの形式は特に定められていないのでテキスト形式でもよいのですが、**構造化ログ**はオブザーバビリティを向上させることができます。
構造化ログでは、JSONやlogfmt形式のログが一般的に使用されています。
ログが構造化されていると機械が解析することが容易なため、オブザーバビリティ向上の役に立ちます。

ログは以下のようなレベルで分類されることが多いです。

- **ERROR**
    - 障害の発生とその理由の詳細を伝えるメッセージ
    - スタックトレースや実行の結果などの問題の診断情報を十分に出力する
- **WARN**
    - 障害ではないが、注意を必要とするレベルのメッセージ
    - 将来なにか問題があった際に見返してほしいメッセージ
- **INFO**
    - システムがどのように機能するのかを理解するためのメッセージ
    - サーバーの起動やリクエストの到着などのメッセージを出力する
- **DEBUG**
    - デバッグ中に使用されるメッセージ
    - プロダクション環境で通常は無効化しておき、問題が起きたときに有効化する

ログは基本的に何でもできるのですが、効率性を考えて他のシグナルと併用する必要があります。
例えばサービスで発生するイベントとその詳細をすべてログに出力することで、オブザーバビリティを向上させることができます。
しかし、データの量が多くなり、ストレージのコストの増加や検索のパフォーマンスの低下が発生するため、現実的ではありません。

### トレース

![トレース](/images/o11y-trace.png)

**トレース**とは、リクエスト処理の全体像をスパンの集合として表現したものです。
例えば1つのリクエストで、いつ、どの処理が呼ばれ、どれくらい時間がかかったかをなどを表しています。
一つのリクエストの開始と終了までの単位をトレースと呼び、リクエスト内の各操作がスパンとして表現されています。

トレースは、トレースID、スパンID、親スパンID、タイムスタンプ、期間などで構成されます。
トレースのルートのスパンがトレースIDを作成し、トレース内のスパンで共有します。
スパンはネストすることができるので、その場合には親スパンIDを使用します。

### その他のシグナル

## シグナル同士の相関

## さいごに

## 参考資料

- [Observability Whitepaper - CNCF TAG Observability](https://github.com/cncf/tag-observability/blob/f7c201f8cd6361047c7c0c04d4d7318e201abf47/whitepaper.md)
- [オブザーバビリティ入門：これから始める方への基本コンセプトとツール](https://www.youtube.com/watch?v=PBI5NPdLsbQ)
- [オブザーバビリティには限りがない話](https://kanatoko.wordpress.com/2024/09/22/%e3%82%aa%e3%83%96%e3%82%b6%e3%83%bc%e3%83%90%e3%83%93%e3%83%aa%e3%83%86%e3%82%a3%e3%81%ab%e3%81%af%e9%99%90%e3%82%8a%e3%81%8c%e3%81%aa%e3%81%84%e8%a9%b1/)
- [監視からオブザーバビリティへ〜オブザーバビリティの成熟度](https://speakerdeck.com/newrelic2023/20230523-findy-newrelic-o11y1)
- [OpenTelemetry を使ったトレースエグザンプラーの活用](https://speakerdeck.com/k6s4i53rx/otel-trace-exemplar)
- [オブザーバビリティ入門](https://speakerdeck.com/cybozuinsideout/introduction_to_observability-2023)

僕も読めていないのですが、詳しく学ぶのであれば以下の書籍が良さそうです。
この投稿は以下の書籍をまとめてくださっている記事を参考にして書いています。

- [オブザーバビリティ・エンジニアリング - O'REILLY](https://www.oreilly.co.jp/books/9784814400126/)
