> [!info]
> OAuthは認証のための技術ではありませんが、OAuthが認証に利用されたり、
> 認証のための仕組みとなるOIDCのベースになっているため、OIDCと一緒にまとめています。

Webアプリやスマホアプリを作っていると、ログイン機能が欲しくなるのはよくあることだと思います。
FWの機能を使うことによって、IDとパスワードを使用したログイン機能をシンプルに実装することはできるかもしれませんが、
機密情報であるパスワードはできるだけ保存したくありません。
そこで、OAuthやOIDC(OpenID Connect)を使ったソーシャルログインがあります。

この投稿は、ソーシャルログインを実装する際に使用できる技術であるOAuthとOIDCについて調べたことを、自分の理解のためにまとめたものです。

## 認証と認可

OAuthとOIDCは、それぞれ**認可**(authorization)と**認証**(authentication)のための仕様です。
認証と認可には以下のような違いがあります。

- 認証は「誰であるかを確認すること」
- 認可は「誰かが誰かに対して何らかの権限を与えること」

認証は本人確認であり、登録されているユーザーと同じユーザーなのかを確認することだと言えます。
認証方法としてはIDとパスワード・生体認証などがあり、ユーザーを特定できる一意な識別子を使用します。

認可は認証よりも要素が多く、「誰が」「誰に」「なんの権限を」という３つの要素が出てきます。
例えば、「ユーザーがアプリにGoogleプロフィールアクセスの権限を与える」といった操作が考えられます。
このうち「誰が」という要素を決めるために認証が行われます。

また、認証とセッション管理を混同しないように注意が必要です。
セッション管理は認証されたユーザーのログイン状態を管理することを指すので、認証したあとにセッションを開始するという意識を持つ必要があります。
混同してしまうと、「認証された」という情報だけでセッション管理を行ってしまい、
セッションの有効期限をコントロールできなくなるといった問題が起きる可能性があります。

## OAuth/OIDCの概要

OAuthは認可の仕組みであり、OIDCはOAuthに認証の仕組みを追加した拡張仕様だと言えます。
そのため、OIDCの処理フローはOAuthがベースになっており、OAuthの処理フローの中で認証のための情報を発行できるようになっています。
OAuthは認証方法について範囲外だと明記しているのですが、認証に使われることもあります。これについては後述します。

OAuthは主に、認可の結果得られる**アクセストークン**に関する仕様です。
アクセストークンは権限を持っている証であり、このトークンを使用してAPIアクセスを行うことができます。
OAuthではアクセストークンの取得方法や利用方法などが定義されています。

OIDCは主に、認証の結果得られる**IDトークン**に関する仕様です。
IDトークンは認証されたユーザーの識別子や発行された時刻などの情報が含まれており、認証イベントの情報だと言えます。
IDトークンを見ることによって、ある認証に関連する様々な情報を得ることができます。
OIDCではIDトークンの構造や取得方法などが定義されています。

## トークン

OAuthやOIDCは主にトークンの取得方法に関する仕様です。
ここでは、それぞれのトークンがどのような構造を持っていて、どのように使われるかについて見ていきます。

### アクセストークン

アクセストークンは通常ランダムな文字列になっていますが、好きな形式でデータを持たせることができます。
例えばアクセストークンとして後述するJWTを使用するための仕様があります。

アクセストークンはAPIアクセスで使われることを目的としており、
それ以外の場所でアクセストークンの中身を確認するという使い方は設計が間違っている可能性があります。

### IDトークン

IDトークンは文字列で表現されます。その構造は以下のようになっています。

```txt
<ヘッダー>.<ペイロード>.<署名>
```

この構造は**JWS**(JSON Web Signature)という形式です。
3つの部分をそれぞれbase64urlでエンコードしたものをピリオドでつなげています。
ヘッダーはJSON形式で、検証に使用するアルゴリズムが`alg`パラメータに入っています。
ペイロードの形式は自由で、JSONや他の形式のデータを含めることができます。
署名は`alg`パラメータに応じた値が入っています。
署名の対象となっているのは`<ヘッダー>.<ペイロード>`の値です。
`alg`パラメータが`RS256`であれば、RSAの公開鍵を使用して署名を検証します。

また、IDトークンの形式としてJSWの他に**JWE**(JSON Web Encryption)と呼ばれる形式が使用されることもあります。
これはIDトークンを暗号化したい際に使用されますが、ここではJWSを前提に話を進めます。

IDトークンでは、ペイロードにJSON形式のデータが入っています。
このようにJWSのペイロードにJSON形式のデータが埋め込まれている構造を**JWT**(JSON Web Token)といいます。
JWTでは、JSONのキーバリューのペアをクレーム(claim)と呼びます。

ここまでがIDトークンの形式になります。
IDトークンは、**JWT**形式のデータであり、JWTは**JWS**(や**JWE**)のペイロード部分にJSON形式のデータが埋め込まれたものです。

IDトークンでは、認証に関する以下のようなクレームが定義されています。

- **iss**: トークンを発行したサーバーの識別子
- **sub**: 認証されたユーザーの識別子
- **aud**: トークンの発行を依頼したサービスの識別子
- **exp**: トークンの有効期限
- **iat**: トークンが発行された日時

OIDCにおけるIDトークンは認証イベントやユーザーを表現するための使われるもので、セッショントークンについての言及はありません。
基本的にはIDトークンを使ってユーザーを認証したあと、独自にセッション管理を実装する必要があります。
IDトークンでセッション管理を行おうとする場合はOIDCから外れることになるのですが、
FirebaseやAuth0のようなIDaaSではセッショントークンとしてIDトークンが使われているので注意が必要です。

## 登場人物

OAuth/OIDCではロールとロール間のやり取りが定義されています。
OIDCはOAuthで定義された用語を別の呼び方で呼ぶことがありますが、役割としては同じと考えて良いと思います。
その中で認証に関するものは以下のとおりです。( <OAuthの用語>/<OIDCの用語> )

- **リソースオーナー/エンドユーザー**
  - 認証しようとしているユーザー
- **クライアント/Relying Party(RP)**
  - エンドユーザーの許可を得てIdPからトークンを取得するサービス
  - ClientSecretを安全に管理できる**Confidential**・安全に管理できない**Public**
- **認可サーバー/OpenID Provider(OP)・IdP**
  - トークンを発行するサーバー
  - 認可エンドポイント・トークンエンドポイントを持つ
- **UserInfo API**
  - トークンを使ってユーザーのプロフィール情報を取得するためのAPI
  - OIDCでは仕様で定義されているが、OAuthでは定義されていない
  - OAuthではリソースを管理している**リソースサーバー**で実装される事が多い

WebアプリにGoogleアカウントでログインできる場合、エンドユーザーはログインしたいユーザー、クライアントはWebアプリ、IdP・UserInfo APIはGoogleになります。

クライアントはClientSecretを安全に管理できるかによってConfidential・Publicクライアントに分かれています。
例えばWebアプリのバックエンドはConfidentialであるとみなせますが、SPAやモバイルアプリ、デスクトップアプリはPublicです。
Publicなクライアントは、バイナリ解析でClientSecretが取得できることがあります。
また、攻撃者が自身のクライアントを改ざんすることも可能なため、検証の意味がなくなるケースもあります。

認可サーバーには認可エンドポイントとトークンエンドポイントがあり、後述する認可フローによって何が使用されるかが決まっています。
認可エンドポイントはトークンエンドポイントに必要な情報を取得するためのエンドポイントですが、
認可エンドポイントからトークンが返ってくる特殊なフローもあります。

UserInfo APIはOIDCでは定義されているのですが、OAuthでは仕様の中に存在しません。
OAuthではリソースが保管されているリソースサーバーに独自仕様のUserInfo APIが存在することになります。
OAuthによる認証のためにはUserInfo APIが必須なため、厳密に言うとOAuthだけで認証することはできません。
OIDCではUserInfo APIがなくても認証することができます。

## OAuth/OIDCのフロー

### OAuthのフロー

OAuthでは認可を行うための4つのフローと、アクセストークンの再発行のためのフローが定義されています。

- **認可コードフロー**
  - 認可エンドポイントから認可コードを取得し、認可コードを使用してトークンエンドポイントからトークンを取得する
  - 基本的なフロー
- **インプリシットフロー**
  - 認可エンドポイントから直接トークンを取得する
  - 利用を避けるべきフロー
- **リソースオーナー・パスワード・クレデンシャルズフロー**
  - クライアントにID/PWを渡し、トークンエンドポイントからトークンを取得する
  - 使ってはいけないフロー
- **クライアント・クレデンシャルズフロー**
  - クライアントのIDとSecretを使ってトークンエンドポイントからトークンを取得する
  - ユーザーが関与しないフロー
- **リフレッシュトークンフロー**
  - リフレッシュトークンを使ってトークンエンドポイントからトークンを再発行する
  - トークンを再発行するフロー

OAuthでは、認可エンドポイントへのリクエストを**認可リクエスト**、レスポンスを**認可レスポンス**と呼びます。
また、トークンエンドポイントへのリクエストを**トークンリクエスト**、レスポンスを**トークンレスポンス**と呼びます。

認可リクエストには`response_type`パラメータが存在しており、`code`の場合には認可コードフロー、`token`の場合にはインプリシットフローを要求します。

上記のフローでアクセストークンを取得することができるので、UserInfo APIにアクセスしてプロフィール情報を取得し、
ユーザーの識別子を使ってログイン処理を行えます。

### OIDCのフロー

OIDCでは認可リクエストの`response_type`パラメータに`id_token`を渡せるようにすることで、
IDトークンの発行を可能にしています。IDトークンを取得するリクエストは`scope`パラメータに`openid`を含める必要があります。

このような拡張のため、OIDCでは認可リクエストは**認証リクエスト**と呼ばれることもあります。
また、あわせてレスポンスも**認証レスポンス**と呼ばれることもあります。

以下は`scope`パラメータに`openid`が含まれていてる場合のOIDCのフローの一部です。

- **`response_type=code`**
  - OAuthの認可コードフローがベース
  - 認可コードでトークンエンドポイントからアクセストークンと一緒にIDトークンを取得する
- **`response_type=code id_token`**
  - OAuthの認可コードフローがベース
  - 認可エンドポイントから認可コードと一緒にIDトークンを取得する
- **`response_type=id_token`**
  - OAuthのインプリシットフローがベース
  - 認可エンドポイントから認可コードではなくIDトークンを取得する

上記のフローでIDトークンを取得することができるので、IDトークンに含まれる識別子(sub)を使用してログイン処理を行えます。

## 認可コードフローによる認証

一般的に使用されるOAuth/OIDCの認可コードフローを例にとって、ログインのフローを具体的に解説していきます。
フローは以下のようになります。

![login-flow](/images/login-flow.png)

ここでは、WebアプリがGoogleログインを実装しているケースを想定しています。WebアプリなのでConfidentialクライアントです。

- **ログインリクエスト**
  - エンドユーザーがクライアントにログインのためのリクエストを送ります
  - 「Googleアカウントでログイン」のようなボタンを押すことになると思います
- **IdPにリダイレクト・認証リクエスト**
  - クライアントはログインリクエストを受け取ると、IdPへの認証リクエストのためのURLを生成し、そのURLへのリダイレクトレスポンスとして返します
  - OIDCを使用するので`scope`に`openid`を含め、認可コードフローなので`response_type`に`code`を渡すURLを作成します
    - URL例: `/authorize?response_type=code&scope=openid...`
- **認証画面・認証**
  - 認証リクエストのレスポンスとして、ユーザーに認証画面が返されるので認証を行います
  - このやり取りは必ず実行されるわけではなく、IdPの実装によっては、すでに認証している場合には省略されることがあります
    - WebアプリにGitHubアカウントでログインできる場合で、すでにGitHubのサイトでログインしているケースなど
  - OIDCでは認証リクエストの`prompt`パラメータに`none`を指定することで常に省略でき、認証していない場合には次の処理でエラーレスポンスが返ってきます
- **クライアントにリダイレクト・認証レスポンス**
  - 認証リクエストや認証を受け取るとIdPは認可コードを発行して事前に登録されているクライアントのURLに埋め込み、そのURLへのリダイレクトレスポンスとして返します
    - URL例: `/login/callback?code=...`
- **トークンリクエスト・レスポンス**
  - クライアントはIdPからのコールバックによって認可コードを取得できた場合、その認可コードを使ってトークンエンドポイントにアクセスし、トークンを取得します
  - この例ではアクセストークンとIDトークンが取得できます
- **プロフィール情報のリクエスト・レスポンス (OAuthのみ)**
  - OAuthで認証を実装する場合には、ここでUserInfo APIにアクセスしてユーザー識別子を含むプロフィール情報を取得します
  - 前述した通り、OAuthの仕様にはUserInfo APIは存在しないため、独自実装されたUserInfo APIを使うことになります
- **識別子で認証**
  - OAuthではプロフィール情報のユーザー識別子を使用して、OIDCではIDトークンの識別子(sub)を使用してユーザーを認証します
  - ここでは例えば、クライアントが管理しているユーザーの情報とユーザー識別子を比較して、存在すればログイン状態にするなどの処理が考えられます
  - 認証の後にセッションを開始させるような処理もあると思います
- **ログインレスポンス**
  - ログインに成功したか、失敗したかのレスポンスなどを返します
  - ログインに成功した場合は、cookieにセッションIDがセットされているかもしれません

### OAuthを使用した認証について

OAuthは認可のための仕組みなのですが、上の図ではOAuthを使用した認証も行えることを表しています。
(UserInfo APIはOAuthの仕様にはないので、OAuthの使用だけで認証が実装できるわけではないのですが・・・)
上のように、クライアントがConfidentialであり、エンドユーザーのアクセストークンであること・アクセストークンから取得したユーザー識別子がエンドユーザーのものであることが保証できる場合、認証を安全に実装することはできます。

一方で、クライアントがPublicな場合には、「エンドユーザーのアクセストークンであること」を保証するのが難しいです。
具体的には、モバイルアプリ(Publicなクライアント)とWebアプリ(Confidentialなクライアント)があり、
モバイルアプリからWebアプリにアクセストークンを渡して、WebアプリがUserInfo APIにアクセスして認証するようなケーがあります。
エンドユーザーのアクセストークンであることを保証するのが難しいため、アクセストークンが漏れると勝手に使用される可能性があります。
この場合、認可サーバーがアクセストークンとクライアントのセッションを紐づけておく必要があり、認可サーバーにも仕様から外れた独自実装が必要になります。

また、OAuthは認証のための仕様ではないため、認証の複雑な要件に対応するための労力が大きいです。
認証の必要最低限の要件は、ログインしようとしているユーザーの識別子を取得できることです。
これはOAuth + UserInfo APIで比較的簡単に実現できるのですが、更に複雑な要件を実現するためには、すべて自分で設計して実装する必要があります。

複雑な要件の例としては、認証方法の指定や、ClientとIdP間のセッション管理などがあります。
OIDCには、認証方法の指定は[認証コンテキストクラス](https://qiita.com/TakahikoKawasaki/items/185d34814eb9f7ac7ef3#16-%E8%AA%8D%E8%A8%BC%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%AF%E3%83%A9%E3%82%B9)というものを認証リクエスト時に指定できるような仕様があったり、[セッション管理についての仕様](https://ritou.hatenablog.com/entry/20151104/1446597256)が存在しています。

認証では、OIDCが使えるのならば使わない理由はないです。
OIDCはOAuthと違って仕様の範囲内で認証を実装することができ、複雑な要件も仕様でサポートされていることがあります。

## セキュリティ対策

認証フローの中でセキュリティ対策については考えていませんでしたが、いくつかの攻撃が考えられます。
ここではその対策として使用できる技術について紹介していきます。

OAuth/OIDCへの攻撃としてCSRFがありますが、一般的なCSRFとは目的が少し異なっていることが特徴です。
一般的なCSRFでは、攻撃者が標的となったユーザーになりすまして何らかの処理を実行する事が多いのですが、
OAuth/OIDCでは、攻撃者が標的となったユーザーに自身のリソースを紐づけることを目的としています。

攻撃者は標的ユーザーに自身のリソースを紐づけることで、標的ユーザーのプライベートなデータにアクセスできたり、攻撃者のアカウントで標的ユーザーとしてログインできてしまいます。
前者は、クライアントが外部のGoogleストレージにデータを保存するようなケースで、攻撃者のGoogleストレージに紐づけられると、攻撃者のGoogleストレージに標的ユーザーのデータが保存されることになります。
後者は、クライアントがGoogleログインを実装しているケースで、攻撃者のGoogleアカウントと連携すると、攻撃者のGoogleアカウントで標的ユーザーとしてログインすることができてしまいます。

これから紹介するセキュリティ対策は、値が同一のセッションに紐づいていることを検証するのですが、セッションを「一連の処理」という意味で使っています。
具体的には、ユーザーとクライアントとIdP間の、認証処理の開始から最終的なレスポンスを受け取るまでの一連の処理をセッションと呼んでいます。
一般的にセッションと言うとログインセッションことを指すことが多いと思うのですが、ここではそのような意味では使っていません。

セッションと値を紐づける方法としては、cookieに値をセットするのが手軽な方法だと思います。
Webアプリではcookieを使うことによって特定のユーザー(ブラウザ)とクライアント(Webアプリ)で閉じたデータのやり取りができるようになります。
ログインセッションのように、cookieにはIDだけを含めて、バックエンドで値を管理することもできるとは思います。

### state

stateパラメータは、**認証リクエストと認証レスポンスが同一のセッションに紐づいている**ことを確認するために使用できるパラメータで、**CSRF攻撃の対策**として使われます。
認証リクエスト時にセッションに紐づくstateを生成して送信すると、渡したstateが認証レスポンスに含まれているため、セッションに紐づくstateと比較して検証できます。

想定される認可コードフローにおけるCSRF攻撃は以下のような流れになります。

![csrf-attack](/images/csrf-attack.png)

攻撃者は正規のクライアントでフローを開始して、クライアントへの認証レスポンスのリダイレクトをキャンセルして、そのURLを標的ユーザーに送ります。
標的ユーザーは、自分が送信していない認証リクエストへの認証レスポンスをクライアントに送ってしまい、攻撃者のリソースと紐づけられてしまいます。

この攻撃が発生してしまうのは、認証リクエストを発行したセッションと認証レスポンスを受け取ったセッションが異なっていても、通常通り処理が進んでしまうからです。

この攻撃への対策の流れは以下のようになります。

![csrf-state](/images/csrf-state.png)

- クライアントはログインリクエストを受け取ると、stateを生成してセッションと紐づけ、認証リクエストのstateパラメータに付与する
  - セッションに紐づける方法としては、リダイレクトの認証リクエストで`set-cookie`にstateを含める方法などがあります
- IdPは認証リクエストで受け取ったstateパラメータを認証レスポンスに含める
- クライアントは認証レスポンスを受け取ったら、セッションに紐づくstateと認証レスポンスに含まれているstateを比較して検証する
  - 上のように`set-cookie`でstateをセットすると、認証レスポンスの`cookie`としてセッションに紐づくstateを取得できます
- 攻撃者と標的ユーザーのセッションは別であり、攻撃者は標的ユーザーのstateを事前に知ることはできないため、検証に失敗する

注意点は、stateの生成・検証を行うのはクライアントであるということです。
仕様としてstateパラメータは定義されていますが、クライアントはそれを正しく実装しない可能性があります。
例えばstateをセッションに紐づく値ではなく、完全に固定している場合には意味がありませんし、そもそもクライアント側で検証しないといった実装も考えられます。

また、認証レスポンス自体はセッションに紐づいていることを確認できるのですが、認可コードの値も必ず紐づいているとは言えません。
認証レスポンスはブラウザを通したリダイレクトになっており、認可コードの書き換えを検出できない可能性があります。

このような状況は、`response_type=code id_token`を認証リクエストに含めて、認可コードと一緒にIDトークンを取得することで対処できます。
`response_type`が上のように指定されると、IDトークンに`c_hash`と呼ばれる認可コードのハッシュ値が含まれるので、これを検証することで改ざんを検出できます。

### nonce

nonceパラメータは、OIDCにおいて**認証リクエストと特定のレスポンスが同一のセッションに紐づいている**ことを確認するために使用できるパラメータで、
**IDトークンのリプレイアタックの対策**として使われます。どのレスポンスと紐づいているかはフローによって異なります。
認証リクエスト時にセッションに紐づくnonceを生成して送信すると、渡したnonceがIDトークンのnonceクレームに含まれているため、セッションに紐づくnonceと比較して検証できます。

OIDCではIDトークンの取得方法として`response_type`に`id_token`を含めて認可コードと一緒に取得する方法と、トークンエンドポイントから取得する方法で2種類あり、
それぞれでセッションがどのレスポンスに紐づいているかが変わってきます。

`response_type`に`id_token`を含めて認可コードと一緒にIDトークンを取得する場合、
**認証リクエストと認証レスポンス、トークンリクエスト・レスポンスが同一のセッションに紐づいている**ことを確認できます。
このケースは、認証リクエストと認証レスポンスが同一セッションに紐づいていることを検証できるため、stateパラメータの代わりに使うことができます。

IDトークンをトークンエンドポイントから取得する場合、**認証リクエストとトークンレスポンスが同一のセッションに紐づいている**ことを確認できます。
上の方法と比べるとIDトークンを取得するタイミングが遅いため、IDトークンを取得する前の、
認証レスポンスとトークンリクエストの時点ではそれらがセッションに紐づいていることを確認できません。
トークンレスポンスが紐づいていることが確認できた段階で、それ以前のやりとりも紐づいていることが保証されます。

また、nonceはリプレイアタックを防ぐことができるのですが、この攻撃はフローによって難易度が変わってきます。
Confidentialクライアントの認可コードフローの場合はクライアントとIdP(トークンエンドポイント)のやり取りに介入する必要があるので難易度が高いです。
一方でインプリシットフローの場合は、IDトークンが流出する可能性が高かったり、IDトークンを書き換えるのが難しくないため、難易度が低いです。

以下の図はConfidentialクライアント + インプリシットフローに対してのIDトークンのリプレイアタックを想定しています。
そういった事例があるかわからないのですが、クライアント側でClientSecretを保管したくない場合に使われることがあるかもしれません。
OIDCではトークンエンドポイントへのリクエストでクライアント認証が行われますが、認可エンドポイントでは行われないため、Secretを保管する必要がなくなります。

![replay-attack](/images/replay-attack.png)

攻撃者はどうにかして事前に標的ユーザーのIDトークンを取得しておき、認証レスポンスをキャンセルしてIDトークンを書き換えます。
クライアントは受け取ったIDトークンの識別子を確認して、標的ユーザーとして認証してしまいます。

この攻撃が発生してしまうのは、IDトークンを発行したセッションとIDトークンを使用するセッションが異なっていても通常通り処理が進んでしまうからです。

この攻撃への対策の流れは以下のようになります。

![replay-nonce](/images/replay-nonce.png)

- クライアントはログインリクエストを受け取ると、nonceを生成してセッションと紐づけ、認証リクエストのnonceパラメータに付与する
  - セッションに紐づける方法として、HttpOnly属性付きのcookieに保存する方法があります
    - 攻撃者は標的ユーザーのIDトークンのnonceを知っているので、cookieが書き換えられないようにHttpOnly属性が必要です
- IdPは認証リクエストで受け取ったnonceパラメータをIDトークンのnonceクレームに含める
- クライアントはIDトークンを受け取ると、セッションに紐づくnonceとIDトークンのnonceクレームを比較して検証する
- 攻撃者は標的ユーザーのIDトークンのnonceを知ることはできるが、攻撃者と標的ユーザーのセッションは別であり、攻撃者自身のセッションに紐づくnonceを書き換えることができないため、検証に失敗する

この方法もstateパラメータと同じく、クライアントが値を生成・検証を行うことに注意する必要があります。
常に同じ値が生成されたり、検証していない場合には意味がありません。

### PKCE

PKCE(Proof Key for Code Exchange by OAuth Public Clients)は、**認証リクエストとトークンリクエストが同一のセッションに紐づいていること**を確認するために使用できる技術で、**認可コード横取り攻撃の対策**や**CSRF攻撃の対策**として使われます。
認証リクエスト時にセッションに紐づく値を生成し、それをハッシュ化した値を送信した後、トークンリクエストにセッションに紐づく値を渡すことで、IdP側でハッシュ化して検証できます。

以下の図は、モバイルアプリ(Publicクライアント)での認可コード横取り攻撃を想定しています。
モバイルアプリではカスタムURIスキームによってクライアントへのリダイレクトが実装されることがあり、
正規のクライアントと同一のRedirect Endpointによって起動するアプリを作成されると、以下のように認証レスポンスが奪われる可能性があります。

![intersepction-attack](/images/interception-attack.png)

攻撃者が作成したモバイルアプリに認可コードを横取りされてしまうため、正規のクライアントになりすまして、標的ユーザーのトークンを取得できてしまいます。

この攻撃が発生してしまうのは、認証リクエストを発行したクライアントとトークンリクエストを発行したクライアントが異なっていても通常通り処理が進んでしまうからです。

この攻撃への対策の流れは以下のようになります。

![intersepction-pkce](/images/interception-pkce.png)

- クライアントはログインリクエストを受け取ると、code_verifierを生成してセッションと紐づけ、code_verifierのハッシュを取って認証リクエストのcode_challengeパラメータに付与する
  - セッションと紐づけるために、code_verifierをクライアントに保存することができます
  - 実際にはcode_challenge_methodパラメータでハッシュのアルゴリズムも指定しています
- クライアントがトークンリクエストの際にセッションに紐づくcode_verifierをIdPに送り、IdPがハッシュを取って認証リクエスト時のcode_challengeと比較して検証する
- 攻撃者のクライアントは正規のクライアントとは別のセッションになるため、認証リクエストを発行した時点でのcode_verifierを知ることができず、検証に失敗する

PKCEはstateやnonceと同じように値の生成はクライアントで行うのですが、検証はIdPが行うことになります。
code_verifierとして同じ値を生成していると意味がなくなるのですが、クライアントではなくIdPで検証することが定義されているため、
検証忘れを防げます。

認可コードフローを使用する場合には、PKCEはCSRF対策として使用できるためConfidentialクライアントでも推奨されています。
stateで紹介したCSRF攻撃の対策は以下のようなものでした。

![csrf-state](/images/csrf-state.png)

stateによってCSRF対策を行っていますが、PKCEでも対策することができます。
stateでは、クライアントがトークンリクエストを送信する前に、認証レスポンスのstateを検証することによってCSRF対策を行っていますが、
stateではなくPKCEを使用しても、攻撃者のクライアントと標的ユーザーのクライアントのセッションは異なるため、
トークンリクエストに適切なcode_verifierが送られることはなく、CSRF対策として使用できます。

PKCEだけでCSRF対策を行うことは可能なのですが、IdPへの負荷を考えるのであれば、stateによって早い段階でチェックする方が良いと思います。
stateを使用せずにPKCEだけをCSRF対策として使用すると、本来事前に弾けるはずのトークンリクエストをIdPに送ることになります。
stateで事前に認証レスポンスを検証することで、IdPへの負荷を減らすことができます。

## さいごに

ソーシャルログインの実装に使用できるOAuthとOIDCについてまとめました。

アプリに認証機能を実装する際には考えなければいけないことが多く、独自実装では脆弱性を埋め込んでしまう可能性が高くなってしまいます。
認証機能はID管理機能の一つでしかなく、IDのライフサイクルに応じた様々な機能を実装する必要も出てきます。
そのため、まずはIDaaSの使用を検討するのが良いと思います。

この投稿がOAuthとOIDCへの理解の助けになることを願っています。

## 参考資料

この投稿は、以下の資料を独自にまとめたものです。

- [The OAuth 2.0 Authorization Framework](https://openid-foundation-japan.github.io/rfc6749.ja.html)
- [OpenID Connect Core 1.0 incorporating errata set 1](https://openid-foundation-japan.github.io/openid-connect-core-1_0.ja.html)
- [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)
- [OAuth 2.0 + OpenID Connect のフルスクラッチ実装者が知見を語る](https://qiita.com/TakahikoKawasaki/items/f2a0d25a4f05790b3baa#%E8%AA%8D%E8%A8%BC%E3%81%A8%E8%AA%8D%E5%8F%AF)
- [OAuth & OIDC 勉強会 【入門編】](https://www.authlete.com/ja/resources/videos/20200317/)
- [OAuth認証とは何か?なぜダメなのか - 2020冬](https://ritou.hatenablog.com/entry/2020/12/01/000000)
- [OAuth & OpenID Connect 関連仕様まとめ](https://qiita.com/TakahikoKawasaki/items/185d34814eb9f7ac7ef3)
- [OAuth 2.0 全フローの図解と動画](https://qiita.com/TakahikoKawasaki/items/200951e5b5929f840a1f)
- [OpenID Connect 全フロー解説](https://qiita.com/TakahikoKawasaki/items/4ee9b55db9f7ef352b47)
- [IDトークンが分かれば OpenID Connect が分かる](https://qiita.com/TakahikoKawasaki/items/8f0e422c7edd2d220e06)
- [SPA+Backend構成なWebアプリへのOIDC適用パターン](https://ritou.hatenablog.com/entry/2024/10/22/153014)
- [そのIDTokenの正体はセッショントークン？それともアサーション？](https://ritou.hatenablog.com/entry/2020/01/08/070000)
- [図解：OAuth 2.0に潜む「5つの脆弱性」と解決法](https://atmarkit.itmedia.co.jp/ait/articles/1710/24/news011.html)
- [OAuth 2.0/OpenID Connectで使われるBindingの仕組みについて整理する](https://ritou.hatenablog.com/entry/2019/12/02/060000)
- [OIDCのImplicit FlowでClientSecretを使わずにID連携する](https://zenn.dev/ritou/articles/2796b1cc8b6d32)
- [OAuth 2.0 / OpenID Connectにおけるstate, nonce, PKCEの限界を意識する](https://ritou.hatenablog.com/entry/2019/07/08/070000)
- [Identity Lifecycleを意識したID管理機能の設計](https://ritou.hatenablog.com/entry/2020/12/07/060000)
