
データベースには、トランザクションとACID特性、ロック、アノマリーとトランザクション分離レベルなどの概念がありますが、
それらがどのように関連しているかについて考えたことがありませんでした。

この投稿は、RDBの同時実行制御という観点からそれらの概念を自分の理解のためにまとめたものです。
トランザクション分離レベルについて詳しく整理されている[スライド](https://speakerdeck.com/mpyw/postgres-niokerutoranzakusiyonfen-li-reberu)と[記事](https://zenn.dev/mpyw/articles/rdb-transaction-isolations#postgres)の内容をベースにしています。

## RDBの同時実行制御の概要

### トランザクションと同時実行制御

RDBには、連続した操作の単位としてトランザクションがあり、ACID特性を満たしていると言われています。
ACID特性のなかでわかりやすいと思うのは原子性(Atomicity)で、一連の操作がすべて実行されるか、すべて実行されないかのどちらかであることを保証する性質です。
トランザクション内の一部の操作が失敗した時点で、それ以前の操作はデータベースによってロールバックされ、なかったことにしてくれます。

ACID特性で同時実行制御と深く結びついているものは分離性(Isolation)です。
分離性とは、トランザクションを実行する過程が外のトランザクションから独立して見えないという性質のことです。
最も理想的なのは、複数のトランザクションが同時に実行されても、直列に実行されたような結果になるというもので、Serializableであるといいます。(後から出てくるトランザクション分離レベルで言うSERIALIZABLEもこれを満たしてはいません)

### 同時実行の問題とロック

トランザクションに分離性がない場合には、複数のトランザクションが同時に実行されると問題が発生する可能性があります。
ここでは以下のような問題について考えていきます。

1. 別のトランザクションの変更を上書きしてしまう問題
2. 別のトランザクションがコミットしていない変更を読み取ってしまう問題

1の問題は、口座残高が十分にあるかを確認してから一定金額を引き落とす処理を一つのトランザクションとしたとき、これを同時に実行すると起きます。
あるトランザクションが残高の確認をした直後で、一定金額を引き落とす前に、別のトランザクションが残高の確認をすると、意図しない残高を読み取り、最終的な残高がおかしくなってしまいます。

2の問題は、口座残高を減少させるトランザクションと、口座残高を読み取るトランザクションを同時に実行すると起きます。
残高を減少させる処理が実行されたあと、別のトランザクションが残高を読み取ります。その後、残高を減少させるトランザクションが失敗した場合、
残高を読み取っているトランザクションは、正しくない残高を持っていることになります。

これら問題を解決するために、対象の行をロックして別のトランザクションの読み取りを防ぐという方法が考えられます。
問題1では口座確認の時点で、問題2では残高を減少させる時点でロックを取り、更新を含むトランザクションがコミットされるまで読み取りを待機させることができます。
ロックには排他ロックと共有ロックがあり、共有ロック同士では複数のロックを獲得できるため、排他ロックを使ってロックを1つだけ獲得できるようにする必要はあります。

ロック解放のタイミングが重要なため、 **S2PL (Strict Two Phase Lock)** というロックが使用されます。
このロックは2PLという仕組みの亜種で、トランザクションの終了でのみロックを解放することが保証されています。
分離性を保つために重要なのは、トランザクションが終了してからロックを解放するということです。

データベースのロックはトランザクションの分離性を確保するための重要な機能ですが、**過度なロックの使用はパフォーマンスの低下を引き起こします。**
パフォーマンスのためには、ロックの数を減らしたり、期間を短くする必要が出てきます。
例えば、後述するMVCCによって問題2をロックを使用せずに解決しているデータベースが多くあります。

### トランザクション分離レベル

ANSI(米国国家規格協会)は、分離性が無いことで発生する異常である**アノマリー**に対して、それをどのくらい防ぐかという**トランザクション分離レベル**を定義しています。

トランザクション分離レベルでは、**トランザクションの分離性を妥協してパフォーマンスを重視するような選択肢が用意されています。**
一番強い分離レベルでは、あらゆる操作にロックをかける挙動になっているデータベースもあるのですが、
パフォーマンスの観点から現実的ではなかったり、ある程度の不整合は問題にならないことが多いので、分離性を妥協するための選択肢が用意されています。

ANSIが想定しているアノマリーは以下のとおりです。

- **Dirty Read**
  - 他のトランザクションでコミットされていない値を読み込んでしまう
- **Fuzzy Read**
  - 以前に読み込んだ値を再度読み込んだとき、他のトランザクションによるコミットによって値が変わってしまう
- **Phantom Read**
  - 複数行の集合を一度参照したあと、他のトランザクションのコミットによって集合が変わってしまう

ANSIが定義しているトランザクション分離レベルは以下のとおりです。

- **READ UNCOMMITTED**
  - Dirty Readが起こる
- **READ COMMITTED**
  - Dirty Readは起こらないが、Fuzzy Readが起こる
- **REPEATABLE READ**
  - Fuzzy Readは起こらないが、Phantom Readが起こる
- **SERIALIZABLE**
  - 上記すべてのアノマリーが起こらない

ANSIがこれらを定義したあとにも様々なアノマリーが見つかり、トランザクション分離レベルが更新されたり、新しい分離レベルが増えたのですが、
この記事ではあまり深く掘り下げず、ANSIの定義に従ってまとめていきます。

### MVCCによるスナップショット参照

多くのデータベースでは、ロックを取る代わりに、**MVCC (MultiVersion Concurrency Control)** と呼ばれるアルゴリズムによって、
スナップショットを参照する仕組みが実装されており、分離性とパフォーマンスがある程度両立できています。
これによって、上で紹介しているANSIのアノマリーは、普通の`SELECT`文でもロック無しで防ぐことができます。

この仕組みではSQL文の種類によって、スナップショットと現在のデータのどちらを参照するかが異なっています。

- `SELECT`
  - **一貫性読み取り (Consistent Read)** と呼ばれるアクション
  - スナップショットを参照する
  - ロックを取らない
- `SELECT ... FOR (SHARE | UPDATE)`
  - **ロック読み取り (Locking Read)** と呼ばれるアクション
  - 現在のデータを参照する
  - ロックを取る
- `INSERT`・`UPDATE`・`DELETE`
  - **書き込み (Write)** と呼ばれるアクション
  - 現在のデータを参照する
  - ロックを取る
  
この仕組みでは、スナップショット取得のタイミングより前にコミットされた変更のみが見えるようになっているため、Dirty Readは発生しません。
スナップショットを取得するタイミングでアクティブな(アボートもコミットもされていない)トランザクションはわかるので、
そのトランザクションによる変更を無視できます。

MySQLとPostgreSQLでは、トランザクション分離レベルによってスナップショットを取得するタイミングが異なり、それによって防げるアノマリーが変わってきます。
READ COMMITTEDの場合は各一貫性読み取りの直前に取得され、REPEATABLE READの場合はトランザクションの最初の読み取り時に取得されます。
トランザクションの最初の読み取りでスナップショットが取得される場合、他のトランザクションがコミットしてもスナップショットは変わらないため、Fuzzy Readを防ぐことができます。

## RDBMSごとの同時実行制御

### MySQL

MySQLのトランザクション分離レベルは、基本的にANSIのトランザクション分離レベルのように動作しますが、REPEATABLE READでの一貫性読み取りとロック読み取りの混在には注意が必要です。
ロック読み取りはスナップショットではなく実際のデータを参照するので、一貫性読み取りと結果が異なってしまい、実際にはREAD COMMITTED相当の動作になってしまいます。

REPEATABLE READ以上を使用すると、ロック読み取り/書き込みでは常にロックを取る動作になっています。
ロック読み取り/書き込みでは、レコードをロックする**レコードロック**がFuzzy Readを防ぎ、
値の範囲をロックする**ギャップロック**がPhantom Readを防ぎます。

SERIALIZABLEでは一貫性読み取りがロック読み取りになり、共有ロックを取るようになります。

### PostgreSQL

PostgreSQLのトランザクション分離レベルは、REPEATABLE READでPhantom Readが発生しないため、ANSIのトランザクション分離レベルよりやや強いです。
MySQLでもそうなのですが、PostgreSQLはMySQLのようにトランザクション分離レベルのダウングレードは発生しません。

REPEATABLE READ以上を使用すると、ロック読み取り/書き込みではギャップロックの代わりに更新競合検査を使用して競合を防ぐことができます。
更新競合検査は、これまでのロック (悲観ロック) とは異なり、更新で競合が発生した時点で競合更新エラーが発生する楽観ロックのような仕組みです。
楽観ロックはエラーの機会が増え、エラーハンドリングの必要が出てくるので、競合が少ない場合に使われます。

SERIALIZABLEでは一貫性読み取りやロック読み取り/書き込みで **SIReadロック (Snapshot Isolation Readロック)** という楽観ロックが使われます。
このロックで競合が発生した場合には、直列化異常と呼ばれるエラーが発生します。これは、ANSIのアノマリー後の直列化以上というアノマリーを防ぐことができます。

## RDBMSごとのMVCCの実装

### MySQLのMVCC

### PostgreSQLのMVCC

## さいごに
