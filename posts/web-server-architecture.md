Webアプリを開発していても、Webサーバーについての詳細な知識が必要になることは少ないです。
依然としてWebアプリはWebサーバーの上で動いてはいますが、クラウドのマネージドサービスで動かすことも多くなった現代でそういった知識が必要になるケースは、経験の少ない僕には想像できません。アプリのボトルネックはもう少し高いレイヤーにあることが多く、パフォーマンス改善のためならそちらを学ぶほうが効率が良いと考えています。

ただ、Webアプリを開発しているとWebサーバーがどのように動いているのか気になると思います。僕は気になります。
具体的には、Webサーバーがどのように複数のリクエストを処理しているのかがわかりませんでした。

この投稿はWebサーバーの仕組みについて、ネットワークプログラミングの概要からアーキテクチャまでを調べ、自分の理解のためにまとめたものです。

## Webサーバーとは

Webサーバーとは、リクエストを受けて何らかのデータをレスポンスとして返すソフトウェアやハードウェアのことです。
データとしてはHTMLページ、画像、CSSスタイルシート、JavaScriptファイル、JSONなどがあり、要求に応じてこれらのデータを返します。

現代のWebサーバーは複数のクライアントからのリクエストを並行して処理する必要があります。
一つのリクエストが処理されるまで他のリクエストをブロックするというように、リクエストを一つずつ処理するだけならイメージはつきやすいと思います。
しかし実際には並行処理が行われるため複雑になります。

Webサーバーのアーキテクチャは並行処理の手法の数だけ存在し、詳細を理解するためにはシステムプログラミングの領域に踏み込む必要があります。
アーキテクチャを処理を委譲する実行環境で分けると、マルチプロセス・マルチスレッド・イベント駆動・ハイブリッド・グリーンスレッドなどがあります。
また、各実行環境でリクエストが処理される方法も異なります。

## ネットワークプログラミングの概要

Webサーバーの仕組みを知るために重要なシステムプログラミングの領域はネットワーク通信です。
Webサーバーはクライアントからネットワークを通してリクエストを受け付けたあと、クライアントからデータを受け取ったり、クライアントにデータを渡したりします。

### 基礎知識

ネットワークプログラミングの概要を知るうえで前提となる基礎的な知識について解説します。

#### システムコール

ここではシステムコールを利用するプログラミングをシステムプログラミングと呼びます。

システムコールは、アプリケーションがOSのカーネルの機能を呼び出すための方法です。
現代のCPUではセキュリティのためにユーザーモードとカーネルモードを区別しています。
カーネルモードは無制限の操作が可能ですが、ユーザーモードには制限があります。
OSは、カーネルモードで動作する処理をシステムコールとして提供し、アプリケーションはシステムコールを通じてカーネルモードでの操作を実行します。

代表的なシステムコールとしては、`open`、`read`、`write`、`close`などがあり、ファイルの操作を行います。
後述するネットワーク通信で使用されるソケットに関連するものとしては、`socket`、`bind`、`listen`、`accept`、`connect`などがあります。
他にネットワーク通信で重要になってくるものだと、`select`や`epoll`(`kqueue`)のようなI/Oイベントの通知のためのシステムコールがあります。

#### ソケット

ネットワーク通信では、ソケットと呼ばれるインターフェースが使用されます。

> [!info]
> ソケットにはUDPで通信するためのUDPソケットや、ネットワークに限らないプロセス間通信を行うためのUNIXドメインソケットなどがありますが、ここでは
> ソケットとだけ言う場合にはTCPソケットを指します。

ソケットは通信におけるエンドポイントを表現したデータモデルのことで、

- ローカルIPアドレス
- ローカルTCPポート
- リモートIPアドレス
- リモートTCPポート

が含まれます。
例えばクライアントとWebサーバーが通信しているとき、Webサーバー側のソケットには、Webサーバー自身の情報がローカルIPアドレス・TCPポートに含まれており、
通信先のクライアントの情報がリモートIPアドレス・TCPポートに含まれています。

ネットワーク通信ではソケットを使用してクライアントからデータを受け取ったり、クライアントにデータを渡すことができます。
具体的には、ソケットを読み取ることでデータを受け取り、ソケットに対して書き込むことでデータを渡すことができます。

#### ファイルディスクリプタ

ソケットは**ファイルディスクリプタ**と呼ばれる整数によって参照されます。

ファイルディスクリプタはUnixにおいてプロセス内のファイルを参照するときに使用される整数のことで、Unixでは様々なリソースがこれによって参照されます。
ファイルやソケットのほか、接続されているキーボードや仮想デバイスであるターミナルなどもあります。
ファイルディスクリプタはプロセス内で一意な整数であり、プロセス間では一意な整数にはなっていません。

Unixのこのような思想は「**Everything is a file**」と呼ばれ、統一したインターフェースであらゆるリソースを扱えるようになります。
例えばファイルの読み込み・書き込みとソケットの読み込み・書き込みを同じシステムコールで行えたり、あらゆるリソースのI/Oイベントの通知を一つのシステムコールで監視することができます。

Web開発でもよく見る標準入力、標準出力、標準エラー出力にもファイルディスクリプタが割り当てられており、それぞれ0、1、2になっています。
画面への出力は、標準出力のファイルディスクリプタである1に対してファイル書き込みのシステムコールを実行することで実現できます。

### リクエスト処理フローの概要

ソケットを使用してWebサーバーとしてリクエストを処理するには、ソケットに関するいくつかのシステムコールを呼ぶ必要があります。
リクエストを処理する流れは以下のようになります。

1. ソケットの作成 (socket)
2. ソケットにアドレス割り当て (bind)
3. 接続の待機 (listen)
4. 接続の受け付け (accept)
5. リクエストを処理...
6. ソケットのクローズ (close)

Rubyのsocketライブラリを使って書くと、以下のようになります。

```ruby
require 'socket'

server = Socket.new(:INET, :STREAM) # ソケットの作成
addr = Socket.pack_sockaddr_in(4481, '0.0.0.0')
server.bind(addr) # アドレスの割り当て
server.listen(5) # 接続の待機

connection, _ = server.accept # 接続の受け付け
# リクエストを処理...
connection.close
```

`Socket.accept`はリクエストがあるまで後続の処理をブロックし、リクエストが到着するとクライアントと接続されているソケットを作成します。
`accept`はクライアントとWebサーバーでTCPハンドシェイクによってコネクションを確立した時点でブロックを解除します。

この`accept`で作成されたソケットを読み書きしてクライアントとデータをやり取りします。
`accept`によって作成されるソケットには、WebサーバーのIPアドレスとTCPポートがローカル情報として、
クライアントのIPアドレスとTCPポートがリモート情報として含まれているため、クライアントとの通信に使用できます。

また、Rubyのsocketライブラリでは上のようなコードと合わせてリクエスト処理のループを以下のようなコードで簡単に実装できます。

```ruby
require 'socket'

Socket.tcp_server_loop(4481) do | connection |
  # リクエストを処理...
  connection.close
end
```

### I/Oモデル

ソケットのI/Oに関するモデルについて解説していきます。

#### ブロッキングI/O

ソケットを読み書きする方法として、**ブロッキングI/O**があります。

**ブロッキングI/O**とは、I/O操作の前に待ちが発生して後続の処理がブロックされるI/Oです。
例えばソケットがノンブロッキングモードではない場合の`read`や`write`が該当します。
ブロッキングI/Oの場合、`read`はデータの読み込み準備が完了するまで処理をブロックし、`write`は書き込み準備が完了するまで処理をブロックします。
`read`はEOFを受け取るか最小バイト数を受け取るまで処理をブロックすることもあります。

ブロッキングI/Oを使用したコードは以下のようになります。

```ruby
require 'socket'

Socket.tcp_server_loop(4481) do | connection |
  request = connection.read
  connection.write request

  connection.close
end
```

#### ノンブロッキングI/O

ソケットを読み書きするもう一つの方法は、**ノンブロッキングI/O**です。

**ノンブロッキングI/O**とは、I/O操作の前に待ちが発生しそうなら即座に制御を戻すI/Oです。
例えばソケットがノンブロッキングモードである場合の`read`や`write`が該当します。
ノンブロッキングI/Oの場合、I/O操作の準備ができていない場合にブロックせずに制御が戻ってきます。

ノンブロッキングI/Oを使用したコードの例は以下のようになります。

```ruby
require 'socket'

Socket.tcp_server_loop(4481) do | connection |
  loop do
    begin
      puts connection.read_nonblock(4096)
    rescue Errno::EAGAIN
      retry
    rescue EOFError
      break
    end
  end

  connection.close
end
```

`read`が準備中の場合にはリトライしていますが、あまり意味がないように見えます。
準備中の場合には`Errno::EAGAIN`が発行されるので、準備が完了するまで`read`を呼び続けています。
`read`がブロックしなくなったとはいえ、結局はループが発生しており、ブロッキングI/Oと変わらないように見えす。

#### I/O多重化

ノンブロッキングI/Oの真価は、**I/O多重化**と一緒に使うことで発揮されます。
詳細は後述するWebサーバーアーキテクチャのほうで解説します。

I/O多重化とは、`select`システムコールで複数のファイルディスクリプタを1プロセス1スレッドで管理することを指します。
`select`はI/Oイベントの通知を監視するためのシステムコールですが、効率があまり良くないので現代では効率の良い`epoll`や`kqueue`が使用されます。
インターフェースは異なっていますが、似たようなことを実現するシステムコールなので、ここでは`select`で説明します。

`select`は複数のファイルディスクリプタを監視し、I/O操作の準備が完了しているファイルディスクリプタを返すシステムコールです。
例えばWebサーバーが複数のクライアントと接続している場合、それらのソケットを`select`に渡すと、
I/O操作の準備ができたソケットが返ってきます。
準備ができているソケットがなかったりタイムアウトになるまで`select`は後続の処理をブロックします。

`select`を使用する`IO.select`を使ったI/O多重化のコードは以下のようになります。

```ruby
connections = [<TCPSocket>, <TCPSocket>, <TCPSocket>]

loop do
  ready = IO.select(connections)

  readable_connections = ready[0]
  readable_connections.each do | conn | 
    data = conn.readpartial(4096)
    process(data)
  end
end
```

ここでは3つのソケットを`IO.select`の第一引数に渡し、読み込み準備が完了したソケットのデータが`IO.select`が返す配列の最初の要素に入っています。
`readpartial`は使用可能なデータをすぐに返すRubyの関数ですが、読み込み準備ができていない場合にはブロックします。
`select`から返って来ている時点でI/Oの準備が完了しているとみなしているためこれを使用しています。

`IO.select`は第一引数に読み込みたいIOオブジェクトの配列、第二引数に書き込みたいIOオブジェクトの配列を渡すことができます。
内部で`select`システムコールが呼ばれ、読み込みたいファイルディスクリプタの配列、書き込みたいファイルディスクリプタの配列が渡されます。

このI/O多重化を先述のノンブロッキングI/Oと一緒に使うことができます。
上のコードは事前にソケットが用意されていますが、実際にはどこかのタイミングで`connections`にソケットを詰める必要があります。
ここでノンブロッキングI/Oを使えます。簡単に説明すると、ノンブロッキングI/Oで準備中だとわかったときに`connections`にソケットを詰めることができます。

## Webサーバーアーキテクチャ

### マルチプロセス

### マルチスレッド

### イベント駆動

### ハイブリッド

## Webサーバーの変遷

## リバースプロキシ/ロードバランサ

## さいごに

## 参考資料

- [2015年Webサーバアーキテクチャ序論](https://blog.yuuk.io/entry/2015-webserver-architecture)
- [Webサーバーアーキテクチャ進化論2023](https://blog.ojisan.io/server-architecture-2023)
- [WebエンジニアとWeb技術とシステムの話 (sadnessOjisanのWebサーバーアーキテクチャ進化論2023を読んだ感想)](https://blog.inductor.me/entry/2023/04/03/153149)
- [なるほどTCPソケット(Working with TCP sockets)](https://www.snoozer05.org/naruhotcp)
- [Webサーバにおけるソケット周りの知識](https://christina04.hatenablog.com/entry/socket-base)
- [Non-Blocking I/O, I/O Multiplexing, Asynchronous I/Oの区別](https://christina04.hatenablog.com/entry/2017/07/05/005944)
- [I/O Multiplexing（I/O多重化）](https://christina04.hatenablog.com/entry/io-multiplexing)
- [ノンブロッキングI/Oと非同期I/Oの違いを理解する](https://blog.takanabe.tokyo/2015/03/%E3%83%8E%E3%83%B3%E3%83%96%E3%83%AD%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0i/o%E3%81%A8%E9%9D%9E%E5%90%8C%E6%9C%9Fi/o%E3%81%AE%E9%81%95%E3%81%84%E3%82%92%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B/)
- [ブロッキングI/O, ノンブロッキングI/O, 同期, 非同期](https://zenn.dev/pictogram/scraps/486a9d83689d7c)
- [Boost application performance using asynchronous I/O](https://developer.ibm.com/articles/l-async/)
