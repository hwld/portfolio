---
title: システム設計の基礎をまとめる
createdAt: 2025-01-07
---

> [!note]
> この投稿ではシステム設計をソフトウェアアーキテクチャと同じ意味で使用します。

この投稿は、システム設計の基礎的な知識を自分の理解のためにまとめたものです。

## システム設計とは

**システム設計**とは、システムのアーキテクチャ特性を分析し、それに基づいてシステムの最適な構造を定義するプロセスのことをいいます。
さらに詳しく言えば、アーキテクチャ特性や構造の定義だけではなく、アーキテクチャ決定というルールや設計指針というガイドの策定も含みます。
アーキテクチャ特性は非機能要件のようなもので、詳細については後述します。

システム設計の成果物は、**アーキテクチャ**や**設計**と呼ばれます。
どちらも同じ意味で使われることも多いですが、システム全体の構造をアーキテクチャ、より具体的で詳細なコードレベルの構造を設計と区別することもあります。
このような区別をする場合、システム設計のプロセスで定義するのは、設計ではなくアーキテクチャと言えます。
この投稿ではアーキテクチャと設計は区別はせず、システム全体の構造のことも設計と呼びます。

システム設計は**トレードオフが全て**だと言われています。
システム設計のすべての決定は、多くの相反する要素を考慮しなければならず、何も犠牲にしない決定は存在しません。
あらゆるシステムに最適な一つの設計は存在せず、システムの特性や要件によって最適な設計は変化していきます。
良い設計のためには、複数の選択肢を比較検討し、それぞれのメリットとデメリットを理解したうえで適切なバランスを見つけ出す必要があります。

一度のシステム設計で最適な設計を見つけ出すことは容易ではないため、システム設計はできる限りイテレーティブに行う必要があります。
そのためには、システム設計とシステム開発を分断させずに協調して行い、システム開発からのフィードバックを活かしてシステム設計を反復的に行うことが重要でになってきます。

## 設計におけるコンポーネント

システム設計で定義する構造の最小の構成要素はコードの集まりであり、**コンポーネント**と呼ばれます。
コンポーネントの種類としてはサブシステム・レイヤー・サービスなどがあり、入れ子構造になることもあります。
サブシステムやレイヤーは関連するコードの集まりのことで、サービスは独自のアドレスを持つ通信が可能なコンポーネントです。
この通信にはTCP/IPのような低レベルのプロトコルやHTTPなどのプロトコルが使用されます。

設計者はシステム設計のプロセスの中で、どのようなコードの集まりをコンポーネントとするかを識別して構成し、これが設計における主要な作業になります。
この作業は、あらかじめ決められたコンポーネントを組み合わせるというものではなく、システム全体の特性や要件に合わせて最適なコンポーネントを見つけ出すという作業に近いと言えます。

一番初めにコンポーネントを識別するためには、コンポーネントの**最上位分割**を行うとよいです。
最上位分割とは、システムの最上位のコンポーネントをどのように分割して子コンポーネントを構成していくかの方法のことで、以下のような方法があります。

- **技術による分割**: システムをプレゼンテーション、ビジネスロジック、データアクセスといった技術能力ごとに分割する
- **ドメインによる分割**: システムを顧客管理、商品管理、注文管理といったビジネス上の意味合いに基づいて分割する

最上位分割を行ってコンポーネントを構成するための指針を決めたあと、より具体的なコンポーネントを見つけていきます。
このアプローチには、ロールとアクションを明らかにする**アクター/アクションアプローチ**、ロールとイベントを明らかにする**イベントストーミング**、
ロールとワークフローを明らかにする**ワークフローアプローチ**などがあります。

コンポーネントを識別する際には、そのコンポーネントがシステムの特性や要件を満たせるかについても考慮する必要があります。
コンポーネントの設計をシステムの機能面のみから捉えてしまうと、システムの特性や要件を満たせない可能性があるため、
それらを意識しながら、さらににコンポーネントを分割・統合する必要があります。

初期に行うコンポーネントの識別が良い設計になっている可能性はあまり高くないため、コンポーネントをイテレーティブに改善していく必要があります。
そのため、システム設計はシステムの開発からのフィードバックも重要になってきます。

## アーキテクチャスタイル

コンポーネント同士の一般的な構成パターンは**アーキテクチャスタイル**と呼ばれています。
アーキテクチャスタイルは名前を持っており、
そのスタイルの構造的な側面やサポートされるアーキテクチャ特性、典型的なデプロイメントパターンなどを示すことがあります。

アーキテクチャスタイルはモノリシックアーキテクチャと分散アーキテクチャに分類することができます。
**モノリシックアーキテクチャ**は、すべてのコードが単一のデプロイメントユニットで構成されているアーキテクチャです。
**分散アーキテクチャ**は、なんらかのリモートアクセスプロトコルで接続された複数のデプロイメントユニットで構成されているアーキテクチャのことです。

それぞれのアーキテクチャには以下のような分類が存在します。
この投稿ではそれぞれのアーキテクチャの名前だけを紹介し、どういったアーキテクチャなのかには触れません。

- モノリシック
    - レイヤードアーキテクチャ
    - パイプラインアーキテクチャ
    - マイクロカーネルアーキテクチャ
- 分散
    - サービスペースアーキテクチャ
    - イベント駆動アーキテクチャ
    - スペースベースアーキテクチャ
    - サービス指向アーキテクチャ
    - マイクロサービスアーキテクチャ

分散アーキテクチャは、スケーラビリティや可用性などのアーキテクチャ特性の点でモノリシックアーキテクチャよりも強力ですが、様々な課題が存在し、大きな複雑性をもたらします。
主な課題は「[分散コンピューティングの落とし穴](https://ja.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AE%E8%90%BD%E3%81%A8%E3%81%97%E7%A9%B4)」などと呼ばれています。この他にも様々な考慮事項が存在し、モノリシックアーキテクチャよりも複雑になります。

近年ではマイクロサービスというワードが流行っていますが、分散アーキテクチャは複雑であるため、導入には慎重になる必要があると考えています。
実際にマイクロサービスが必要な企業は多くないのではないかという[指摘](https://aws.amazon.com/jp/blogs/startup/techblog-microservices-introduction/)も存在します。

システムの全体像を決める際にアーキテクチャスタイルを用いることで、設計者はシステムの詳細な設計に集中することができるようになります。
システム構造を定義するアプローチとして、アーキテクチャスタイルを選択した後、各コンポーネントの詳細を決定するというものがあります。

アーキテクチャスタイルを選択するためには、構造に影響する様々な要因を考慮して、「モノリスか分散か？」「データをどこに置くべきか？」「サービス間の通信スタイルは同期か非同期か？」などを決定する必要があります。

## アーキテクチャ特性と関連技術

システム設計で定義する必要のある**アーキテクチャ特性**とは、システムが満たすべき要件のうち、機能に関係せず、構造上の特別な配慮が必要なものをいいます。
これは一般的には非機能要件や品質要件などと呼ばれています。
構造上の特別な配慮が必要というのは要件を満たすためにシステム構造で対応する必要があるということで、
例えばコーディングによってサポートすることを決めた場合はアーキテクチャ特性にはなりません。

一般的にはシステムのデプロイメントユニットごとにアーキテクチャ特性のセットをサポートすることができます。
一つシステムで一つのアーキテクチャ特性のセットをサポートするといった制限はありません。
例えば分散アーキテクチャの各デプロイメントユニットは独自のアーキテクチャ特性のセットをサポートすることができます。
一方でモノリシックアーキテクチャはデプロイメントユニットが一つなので一つのアーキテクチャ特性のセットしかサポートできません。

システム設計のトレードオフの多くは、アーキテクチャ特性間のトレードオフとして捉えることができます。
アーキテクチャ特性は相互に影響し合うため、システムは一部のアーキテクチャ特性しかサポートすることができません。
例えばセキュリティを向上させようとする場合、ほぼ確実にパフォーマンスにマイナスの影響を及ぼします。
あらゆるアーキテクチャ特性をサポートすることは不可能なため、システムに必要なアーキテクチャ特性を分析する必要があります。

**CAP定理**と呼ばれる、一貫性・可用性・分断耐性をすべてサポートすることは不可能だという定理がトレードオフの分析に使われることがありますが、
単純すぎて現実のシステムに当てはめられるものではないという[批判](https://suzuki79.hatenablog.com/entry/2017/11/24/222827)もあります。
CAP定理がいう可用性や一貫性は厳密すぎるため、ほとんどのシステムはどちらもサポートできていないという主張です。

そのため、そういった定理に頼ることなく、自分たちでアーキテクチャ特性のトレードオフについて考え抜く必要があります。

ここからは、以下のアーキテクチャ特性と、関連する技術を簡単に紹介していきます。

- 一貫性
- 可用性
- スケーラビリティ
- パフォーマンス

関連技術は複数のアーキテクチャ特性をサポートすることも多いのですが、サポートする主要なアーキテクチャ特性を独断で決めて、その特性に分類しています。
また、関連技術のレイヤーは揃えておらず、雑多に紹介しています。

### 一貫性

**一貫性**(整合性、Consistency)とは、データが期待される状態にどの程度合致しており、その状態が予測可能であるかをいいます。
期待される状態というのは例えば、「書き込んだデータは読み込める」「変更したデータは反映される」「削除したデータは読み込めない」などです。
クライアントから書き込んだデータを別のクライアントから読み取れるとき、期待される状態といえます。

一貫性には数多くの分類があり、代表的なものは**線形化可能性**や**最終的な一貫性**です。

**線形化可能性**(Linearizability)は、現実的で最も強いとされる一貫性のことです。
データが瞬時に期待された状態になっていることを観測でき、変更が遅延なく伝わっているように見えます。

**最終的な一貫性**(結果整合性、Eventual Consistency)は、最終的に期待された状態になる一貫性のことです。
データを更新したあと、いつかは更新後のデータを読み取れるようになります。

一貫性という用語は文脈によって微妙に意味が異なるため、それらをまとめて大雑把に把握するために**強い一貫性**、**弱い一貫性**、**結果整合性**などと分類することがよくあると思います。
強い一貫性はすべてのデータが瞬時に反映されること、弱い一貫性は反映されない可能性があること、結果整合性はいつかは反映されることを示します。

#### 分散トランザクション

**分散トランザクション**とは、複数のサービスにまたがる一連の処理を、あたかも一つのトランザクションのように扱う技術のことで、一貫性にも関わってきます。
例えば複数のデータベースのデータを更新する場合、一部の更新が失敗していると全体の一貫性は弱くなっていると言えます。
分散トランザクションを使用することで、すべて成功するか・すべて失敗するかという原子性が保証され、一貫性も向上すると思います。

分散トランザクションを実現する方法としては、**2相コミット**や**Sagaパターン**などがあります。

**2相コミット**は、複数の参加ノード間でトランザクションをコミットするかロールバックするかを合意するプロトコルのことです。
具体的には、コーディネーターと呼ばれるノードがすべての参加ノードにコミットの準備ができているかを確認し(準備フェーズ)、
すべてのノードの準備が完了していれば、コーディネーターが全てのノードにコミットの指示を出します(コミットフェーズ)。

2相コミットには、すべてのノードが応答を完了するまでブロッキングするためレイテンシが大きい、ノードの故障や復活で壊れやすいというデメリットがあります。

**Sagaパターン**は、ローカルトランザクション(擬似的なトランザクション)と補償トランザクションによって分散トランザクションを実現するパターンです。
Sagaパターンでは、まず一連の処理を複数の小さな独立したローカルトランザクションに分割します。
ローカルトランザクションは一つのサービスで実行され、成功すれば次のローカルトランザクションに進み、失敗した場合には変更を打ち消すような補償トランザクションを実行します。

Sagaパターンは、各サービスがイベントを介してお互いに連携してトランザクションを調整するコレオグラフィー方式と、
専用のオーケストレーターが各ローカルトランザクションの実行を管理するオーケストレーション方式という2つの手法があります。

Sagaパターンには、失敗した場合の補償処理を適切に実装する必要があり、開発が複雑になりやすいというデメリットがあります。

### 可用性

可用性とは、

#### フェイルオーバー

フェイルオーバーは、

#### レプリケーション

レプリケーションは、

フェイルオーバーを実現するために使うことができる。負荷の分散も。

### スケーラビリティ

スケーラビリティとは、

#### 水平・垂直スケーリング

スケーリングは、

#### ロードバランサ

ロードバランサは、

#### シャーディング

シャーディングは、

### パフォーマンス

パフォーマンスは、

#### キャッシュ

#### 非同期処理

#### CDN

## さいごに

## 参考資料

- [ソフトウェアアーキテクチャの基礎 - O'Reilly](https://www.oreilly.co.jp//books/9784873119823/)
- [データーベースをCPだのAPだのと分類するのはやめて下さい](https://suzuki79.hatenablog.com/entry/2017/11/24/222827)
- [分散コンピューティングの落とし穴 - wiki](https://ja.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AE%E8%90%BD%E3%81%A8%E3%81%97%E7%A9%B4)
- [スタートアップのためのマイクロサービス入門 - AWS](https://aws.amazon.com/jp/blogs/startup/techblog-microservices-introduction/)
- [Eventual Consistencyまでの一貫性図解大全](https://qiita.com/kumagi/items/3867862c6be65328f89c)
- [分散システムについて語らせてくれ#分散合意プロトコルの金字塔](https://www.docswell.com/s/kumagi/ZXYYLN-let-me-talk-about-distributed-system#p24)
- [The System Design Primer](https://github.com/donnemartin/system-design-primer/blob/master/README-ja.md)
- [System Design](https://www.karanpratapsingh.com/courses/system-design)
