---
title: システム設計の基礎をまとめる
createdAt: 2025-01-07
---

> [!note]
> この投稿ではシステム設計をソフトウェアアーキテクチャと同じ意味で使用します。

この投稿は、システム設計の基礎的な知識を自分の理解のためにまとめたものです。

## システム設計とは

**システム設計**とは、システムのアーキテクチャ特性を分析し、それに基づいてシステムの最適な構造を定義するプロセスのことをいいます。
さらに詳しく言えば、アーキテクチャ特性や構造の定義だけではなく、アーキテクチャ決定というルールや設計指針というガイドの策定も含みます。
アーキテクチャ特性は非機能要件のようなもので、詳細については後述します。

システム設計の成果物は、**アーキテクチャ**や**設計**と呼ばれます。
どちらも同じ意味で使われることも多いですが、システム全体の構造をアーキテクチャ、より具体的で詳細なコードレベルの構造を設計と区別することもあります。
このような区別をする場合、システム設計のプロセスで定義するのは、設計ではなくアーキテクチャと言えます。
この投稿ではアーキテクチャと設計は区別はせず、システム全体の構造のことも設計と呼びます。

システム設計は**トレードオフが全て**だと言われています。
システム設計のすべての決定は、多くの相反する要素を考慮しなければならず、何も犠牲にしない決定は存在しません。
あらゆるシステムに最適な一つの設計は存在せず、システムの特性や要件によって最適な設計は変化していきます。
良い設計のためには、複数の選択肢を比較検討し、それぞれのメリットとデメリットを理解したうえで適切なバランスを見つけ出す必要があります。

一度のシステム設計で最適な設計を見つけ出すことは容易ではないため、システム設計はできる限りイテレーティブに行う必要があります。
そのためには、システム設計とシステム開発を分断させずに協調して行い、システム開発からのフィードバックを活かしてシステム設計を反復的に行うことが重要でになってきます。

## 設計におけるコンポーネント

システム設計で定義する構造の最小の構成要素はコードの集まりであり、**コンポーネント**と呼ばれます。
コンポーネントの種類としてはサブシステム・レイヤー・サービスなどがあり、入れ子構造になることもあります。
サブシステムやレイヤーは関連するコードの集まりのことで、サービスは独自のアドレスを持つ通信が可能なコンポーネントです。
この通信にはTCP/IPのような低レベルのプロトコルやHTTPなどのプロトコルが使用されます。

設計者はシステム設計のプロセスの中で、どのようなコードの集まりをコンポーネントとするかを識別して構成し、これが設計における主要な作業になります。
この作業は、あらかじめ決められたコンポーネントを組み合わせるというものではなく、システム全体の特性や要件に合わせて最適なコンポーネントを見つけ出すという作業に近いと言えます。

一番初めにコンポーネントを識別するためには、コンポーネントの**最上位分割**を行うとよいです。
最上位分割とは、システムの最上位のコンポーネントをどのように分割して子コンポーネントを構成していくかの方法のことで、以下のような方法があります。

- **技術による分割**: システムをプレゼンテーション、ビジネスロジック、データアクセスといった技術能力ごとに分割する
- **ドメインによる分割**: システムを顧客管理、商品管理、注文管理といったビジネス上の意味合いに基づいて分割する

最上位分割を行ってコンポーネントを構成するための指針を決めたあと、より具体的なコンポーネントを見つけていきます。
このアプローチには、ロールとアクションを明らかにする**アクター/アクションアプローチ**、ロールとイベントを明らかにする**イベントストーミング**、
ロールとワークフローを明らかにする**ワークフローアプローチ**などがあります。

コンポーネントを識別する際には、そのコンポーネントがシステムの特性や要件を満たせるかについても考慮する必要があります。
コンポーネントの設計をシステムの機能面のみから捉えてしまうと、システムの特性や要件を満たせない可能性があるため、
それらを意識しながら、さらににコンポーネントを分割・統合する必要があります。

初期に行うコンポーネントの識別が良い設計になっている可能性はあまり高くないため、コンポーネントをイテレーティブに改善していく必要があります。
そのため、システム設計はシステムの開発からのフィードバックも重要になってきます。

## アーキテクチャスタイル

コンポーネント同士の一般的な構成パターンは**アーキテクチャスタイル**と呼ばれています。
アーキテクチャスタイルは名前を持っており、
そのスタイルの構造的な側面やサポートされるアーキテクチャ特性、典型的なデプロイメントパターンなどを示すことがあります。

システムの全体像を決める際にアーキテクチャスタイルを用いることで、設計者はシステムの詳細な設計に集中することができるようになります。
コンポーネントの構成を考える際には、まずアーキテクチャスタイルを選んでから、詳細な部分を設計者が決めていくことができます。

アーキテクチャスタイルは**モノリシックアーキテクチャ**と**分散アーキテクチャ**に分類することができます。
**モノリシックアーキテクチャ**は、すべてのコードが単一のデプロイメントユニットで構成されているアーキテクチャです。
**分散アーキテクチャ**は、なんらかのリモートアクセスプロトコルで接続された複数のデプロイメントユニットで構成されているアーキテクチャのことです。

それぞれのアーキテクチャには以下のような分類が存在します。
この投稿ではそれぞれのアーキテクチャの名前だけを紹介し、どういったアーキテクチャなのかには触れません。

- モノリシック
    - レイヤードアーキテクチャ
    - パイプラインアーキテクチャ
    - マイクロカーネルアーキテクチャ
- 分散
    - サービスペースアーキテクチャ
    - イベント駆動アーキテクチャ
    - スペースベースアーキテクチャ
    - サービス指向アーキテクチャ
    - マイクロサービスアーキテクチャ

分散アーキテクチャは、スケーラビリティや可用性などのアーキテクチャ特性の点でモノリシックアーキテクチャよりも強力ですが、様々な課題が存在し、大きな複雑性をもたらします。
主な課題は「[分散コンピューティングの落とし穴](https://ja.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AE%E8%90%BD%E3%81%A8%E3%81%97%E7%A9%B4)」などと呼ばれています。この他にも様々な考慮事項が存在し、モノリシックアーキテクチャよりも複雑になります。

近年ではマイクロサービスというワードが流行っていますが、分散アーキテクチャは複雑であるため、導入には慎重になる必要があると考えています。
実際にマイクロサービスが必要な企業は多くないのではないかという[指摘](https://aws.amazon.com/jp/blogs/startup/techblog-microservices-introduction/)も存在します。

## アーキテクチャ特性と関連技術

システム設計で定義する必要のある**アーキテクチャ特性**とは、システムが満たすべき要件のうち、機能に関係せず、構造上の特別な配慮が必要なものをいいます。
これは一般的には非機能要件や品質要件などと呼ばれています。
構造上の特別な配慮が必要というのは要件を満たすためにシステム構造で対応する必要があるということで、
例えばコーディングによってサポートすることを決めた場合はアーキテクチャ特性にはなりません。

システム設計のトレードオフの多くは、アーキテクチャ特性間のトレードオフとして捉えることができます。
アーキテクチャ特性は相互に影響し合うため、システムは一部のアーキテクチャ特性しかサポートすることができません。
例えばセキュリティを向上させようとする場合、ほぼ確実にパフォーマンスにマイナスの影響を及ぼします。
あらゆるアーキテクチャ特性をサポートすることは不可能なため、システムに必要なアーキテクチャ特性を分析する必要があります。

**CAP定理**と呼ばれる、一貫性・可用性・分断耐性をすべてサポートすることは不可能だという定理がトレードオフの分析に使われることがありますが、
単純すぎて現実のシステムに当てはめられるものではないという[批判](https://suzuki79.hatenablog.com/entry/2017/11/24/222827)もあります。
CAP定理がいう可用性や一貫性は厳密すぎるため、ほとんどのシステムはどちらもサポートできていないという主張です。

そのため、そういった定理に頼ることなく、自分たちでアーキテクチャ特性のトレードオフについて考え抜く必要があります。

ここからは、僕が重要だと考える以下のアーキテクチャ特性と、関連する技術を簡単に紹介していきます。
関連技術は複数のアーキテクチャ特性をサポートすることも多いのですが、サポートする主要なアーキテクチャ特性を独断で決めて、その特性に分類しています。

- 一貫性
- 可用性
- スケーラビリティ
- パフォーマンス

### 一貫性

**一貫性**(整合性、Consistency)とは、データが期待される状態にどの程度合致しており、その状態が予測可能であるかをいいます。
期待される状態というのは例えば、「書き込んだデータは読み込める」「更新したデータは反映される」「削除したデータは読み込めない」などです。

一貫性には強弱があり、

#### 分散トランザクション

### 可用性

可用性とは、

#### フェイルオーバー

フェイルオーバーは、

#### レプリケーション

レプリケーションは、

フェイルオーバーを実現するために使うことができる。負荷の分散も。

### スケーラビリティ

スケーラビリティとは、

#### 水平・垂直スケーリング

スケーリングは、

#### ロードバランサ

ロードバランサは、

#### シャーディング

シャーディングは、

### パフォーマンス

パフォーマンスは、

#### キャッシュ

#### 非同期処理

#### CDN

## さいごに

## 参考資料

- [ソフトウェアアーキテクチャの基礎](https://www.oreilly.co.jp//books/9784873119823/)
- [データーベースをCPだのAPだのと分類するのはやめて下さい](https://suzuki79.hatenablog.com/entry/2017/11/24/222827)
- [分散コンピューティングの落とし穴](https://ja.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AE%E8%90%BD%E3%81%A8%E3%81%97%E7%A9%B4)
- [スタートアップのためのマイクロサービス入門](https://aws.amazon.com/jp/blogs/startup/techblog-microservices-introduction/)
- [Eventual Consistencyまでの一貫性図解大全](https://qiita.com/kumagi/items/3867862c6be65328f89c)
- [The System Design Primer](https://github.com/donnemartin/system-design-primer/blob/master/README-ja.md)
- [System Design](https://www.karanpratapsingh.com/courses/system-design)
